<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Screenshot App</title>
  <style>
    @font-face {
      font-family: 'JetBrains Mono';
      src: local('./fonts/webfonts/JetBrainsMono-Regular.woff2') format('woff2'),
           url('https://cdn.jsdelivr.net/gh/JetBrains/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2') format('woff2'),
           url('https://cdn.jsdelivr.net/gh/JetBrains/JetBrainsMono/web/woff/JetBrainsMono-Regular.woff') format('woff');
      font-display: swap;
      font-weight: 400;
      font-style: normal;
    }

    :root {
      --dot-bg: #000000de;
      --dot-color: #403f3f;
      --dot-size: 1px;
      --dot-space: 22px;
      --primary-bg: #212121;
      --border-color: #333333;
    }

    html, body {
      height: 100vh;
      width: 100vw;
      margin: 0;
      overflow: hidden;
      font-family: 'JetBrains Mono', monospace;
      color: white;
      background: linear-gradient(90deg, var(--dot-bg) calc(var(--dot-space) - var(--dot-size)), transparent 1%) center / var(--dot-space) var(--dot-space),
                  linear-gradient(var(--dot-bg) calc(var(--dot-space) - var(--dot-size)), transparent 1%) center / var(--dot-space) var(--dot-space),
                  var(--dot-color);
    }

    .main-wrapper {
      display: flex;
      height: 100vh;
      width: 100vw;
      gap: 20px;
      padding: 20px;
      box-sizing: border-box;
    }

    .toolbar {
      display: flex;
      flex-direction: column;
      width: 320px;
      min-width: 320px;
      gap: 10px;
      height: calc(100vh - 40px);
      /* overflow-y: auto; */
    }

    .main-content {
      flex: 1;
      min-width: 0;
      height: calc(100vh - 40px);
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .button-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .control-button {
      background-color: rgb(1, 1, 1);
      border: 1px solid var(--border-color);
      color: #6f6f6f;
      padding: 12px;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s ease;
      width: 100%;
      text-align: left;
    }

    .control-button:hover {
      background-color: #010b13;
    }

    .screenshot-img {
      /*max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      image-rendering: crisp-edges; */

      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
      /* object-fit: none; */
      object-fit: scale-down;
      flex-shrink: 0;
    }

    .input-group {
      display: flex;
      gap: 8px;
      width: 100%;
    }

    .coord-inputs {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .coord-input {
      width: 60px;
      padding: 6px;
      background: var(--primary-bg);
      border: 1px solid var(--border-color);
      color: white;
      border-radius: 4px;
    }

    .dark-textarea {
      background-color: var(--primary-bg);
      color: white;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 10px;
      resize: none;
      width: 100%;
      box-sizing: border-box;
    }

    #llmChatInput {
      height: 100%;
      margin-top: 0px;
    }

    #llmChatInput:focus {
      outline: none;
    }

    fieldset {
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 10px;
      margin: 0;
      position: relative;
    }

    #colorsList ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    #colorsList li {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }

    .color-square {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      border: 1px solid var(--border-color);
    }

    .scrollable {
      overflow-y: auto;
      flex: 1;
      min-height: 0;
    }

    /* Connection Status Indicator */
    .connection-status {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 8px;
      background-color: #666; /* Grey - inactive */
    }

    .connection-status.connected {
      background-color: #4CAF50; /* Green - connected */
      box-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
    }

    .connection-status.connecting {
      background-color: #FFC107; /* Yellow - connecting/error */
      box-shadow: 0 0 5px rgba(255, 193, 7, 0.5);
    }

    .connection-button {
      display: flex;
      align-items: center;
    }

    /* Hidden button group */
    .button-group.hidden {
      display: none;
    }

    /* Small toggle button */
    .toggle-buttons-btn {
      position: fixed;
      top: 5px;
      left: 5px;
      width: 10px;
      height: 10px;
      background-color: black; /* #333; */
      border: 1px solid #555;
      border-radius: 50%;
      cursor: pointer;
      z-index: 1000;
      padding: 0;
      margin: 0;
    }

    .toggle-buttons-btn:hover {
      background-color: #444;
    }

    /* FPS Button Styles */
    .fps-button {
      background-color: rgb(1, 1, 1);
      border: 1px solid var(--border-color);
      color: #6f6f6f;
      padding: 2px 6px;
      border-radius: 3px;
      cursor: pointer;
      transition: background-color 0.3s ease;
      font-size: 11px;
      height: 20px;
      min-width: 24px;
      flex: 1;
      text-align: center;
    }

    .fps-button:hover {
      background-color: #010b13;
    }

    .fps-button.active {
      background-color: #2a2a2a;
      color: #ffffff;
      border-color: #555555;
    }

    /* Debug Button Styles */
    .debug-button {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 10px;
      height: 10px;
      background-color: black;
      border: 1px solid #555;
      border-radius: 50%;
      cursor: pointer;
      padding: 0;
      margin: 0;
      z-index: 1;
    }

    .debug-button:hover {
      background-color: #444;
    }

    /* Screenshot placeholder styles */
    .screenshot-placeholder {
      display: flex;
      justify-content: center;
      align-items: center;
      color: #6f6f6f;
      font-size: 14px;
      text-align: center;
      width: 100%;
      height: 100%;
    }
    
    .screenshot-img.hidden {
      display: none;
    }
    
    .screenshot-placeholder.hidden {
      display: none;
    }

    /* Task Management Styles */
    .tasks-section {
      flex: 1;
      min-height: 0;
      display: flex;
      flex-direction: column;
      gap: 10px;
      overflow-y: auto;
      transition: all 0.3s ease;
      max-height: 0;
      opacity: 0;
      transform: translateY(20px);
    }

    .tasks-section.visible {
      max-height: fit-content;
      opacity: 1;
      transform: translateY(0);
    }

    .task-card {
      background-color: var(--primary-bg);
      border: 2px solid;
      border-radius: 8px;
      padding: 12px;
      position: relative;
      animation: waveOutline 3s ease-in-out infinite;
      transition: all 0.3s ease;
    }

    @keyframes waveOutline {
      0% {
        box-shadow: 0 0 5px currentColor, 0 0 10px rgba(255, 255, 255, 0.1);
        border-color: currentColor;
      }
      50% {
        box-shadow: 0 0 20px currentColor, 0 0 30px rgba(255, 255, 255, 0.2);
        border-color: rgba(255, 255, 255, 0.8);
      }
      100% {
        box-shadow: 0 0 5px currentColor, 0 0 10px rgba(255, 255, 255, 0.1);
        border-color: currentColor;
      }
    }

    .task-card.in-progress {
      border-color: #FFC107;
      color: #FFC107;
    }

    .task-card.completed {
      border-color: #4CAF50;
      color: #4CAF50;
    }

    .task-card.broken {
      border-color: #F44336;
      color: #F44336;
    }

    .task-card.canceled {
      border-color: #9E9E9E;
      color: #9E9E9E;
    }

    .task-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .task-status {
      font-size: 12px;
      font-weight: bold;
      text-transform: uppercase;
    }

    .task-cancel-btn {
      background: none;
      border: 1px solid currentColor;
      color: currentColor;
      border-radius: 4px;
      padding: 4px 8px;
      cursor: pointer;
      font-size: 11px;
      transition: all 0.2s ease;
    }

    .task-cancel-btn:hover:not(:disabled) {
      background-color: currentColor;
      color: #212121;
    }

    .task-cancel-btn:disabled {
      cursor: not-allowed;
      opacity: 0.6;
    }

    .task-message {
      font-size: 12px;
      line-height: 1.4;
      word-wrap: break-word;
      max-height: 60px;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .chat-fieldset.shrunk {
      /* flex: 1.5 !important; */
      flex: 1 !important;
      transition: flex 0.3s ease;
    }

  </style>
</head>
<body>
  <div class="main-wrapper">
    <div class="toolbar">
      <div class="button-group hidden" id="mediaButtonsGroup">
        <button class="control-button" id="screenshotBtn">Take Screenshot</button>
        <button class="control-button" id="videoBtn">Video</button>
        <button class="control-button" id="video2">Video 2</button>
        <button class="control-button" id="popOutWSButton">Pop Out WS</button>
      </div>

      <fieldset>
        <legend>Connection</legend>
        
        <!-- Debug Button positioned at top right -->
        <button class="debug-button" id="toggleButtonsBtn" title="Debug"></button>
        
        <!-- FPS Selection -->
        <div class="fps-selector" style="margin-bottom: 10px;">
          <label style="display: block; margin-bottom: 4px; font-size: 12px; color: #6f6f6f;">FPS</label>
          <div class="fps-buttons" style="display: flex; gap: 4px; height: 20px;">
            <button class="fps-button" data-fps="1">1</button>
            <button class="fps-button" data-fps="5">5</button>
            <button class="fps-button" data-fps="10">10</button>
            <button class="fps-button" data-fps="15">15</button>
            <button class="fps-button" data-fps="30">30</button>
          </div>
        </div>

        <div class="input-group">
          <input type="text" id="ipv4" class="dark-textarea" 
                 placeholder="IP Address" 
                 pattern="^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$|^[\da-fA-F:]+$"
                 oninput="this.value=this.value.replace(/[^0-9a-fA-F.:]/g,'')" required>
          <button class="control-button connection-button" id="setTargetIP">
            <span class="connection-status" id="connectionStatus"></span>
            Connect
          </button>
        </div>
        
      </fieldset>

      <fieldset>
        <legend>Mouse Control</legend>
        <div class="coord-inputs">
          <input type="text" id="x-coord" class="coord-input"
                 placeholder="X"
                 pattern="-?[0-9]+"
                 title="Please enter a valid coordinate value."
                 oninput="this.value = this.value.replace(/[^-0-9]/g, '')" required>
          <input type="text" id="y-coord" class="coord-input"
                 placeholder="Y"
                 pattern="-?[0-9]+"
                 title="Please enter a valid coordinate value."
                 oninput="this.value = this.value.replace(/[^-0-9]/g, '')" required>
          <button class="control-button" id="sendMouseInput">Move</button>
          <button class="control-button" id="sendMouseClick">Click</button>
        </div>
      </fieldset>

      <fieldset>
        <legend>Status</legend>
        <p style="margin: auto; font-size: 12px; padding: 5px; width: fit-content;">Total tokens used: <span id="tokenCounter">0</span></p>
      </fieldset>

      <div id="tasksSection" class="tasks-section">
        <fieldset>
          <legend>Tasks</legend>
          <div id="tasksContainer"></div>
        </fieldset>
      </div>

      <fieldset id="chatFieldset" style="flex: 3; display: flex; flex-direction: column; min-height: 200px;" class="chat-fieldset">
        <legend>Chat</legend>
        <textarea id="llmChatInput" class="dark-textarea" placeholder="Type a message..." spellcheck="false" autocorrect="off" autocapitalize="off" autocomplete="off"></textarea>
        <button class="control-button" id="llmSendButton" style="margin-top: 10px;">Send</button>
      </fieldset>
    </div>

    <div class="main-content">
      <div id="screenshotPlaceholder" class="screenshot-placeholder">Video stream will appear here</div>
      <img id="screenshotImg" class="screenshot-img hidden" src="" alt="Video stream">
    </div>
  </div>

  <script>
    let ip = "127.0.0.1";
    let ws = null;
    let videoLoopInterval = null;
    let popOutWSWindow = null;
    const screenshotImg = document.getElementById('screenshotImg');
    const screenshotPlaceholder = document.getElementById('screenshotPlaceholder');
    // Image Fetch Functions
    let currentVideoSession = 0;
    let isConnected = false;
    let buttonsVisible = false;
    let currentFPS = 5; // Default FPS
    // Task Management
    let currentTask = null;
    let isFirstMessage = true;
    
    // Show placeholder initially
    screenshotPlaceholder.classList.remove('hidden');
    screenshotImg.classList.add('hidden');
    

    // Toggle buttons functionality
    function toggleMediaButtons() {
      const mediaButtonsGroup = document.getElementById('mediaButtonsGroup');
      buttonsVisible = !buttonsVisible;
      
      if (buttonsVisible) {
        mediaButtonsGroup.classList.remove('hidden');
      } else {
        mediaButtonsGroup.classList.add('hidden');
      }
    }

    // Update connection button text and functionality
    function updateConnectionButton() {
      const connectButton = document.getElementById('setTargetIP');
      
      if (isConnected) {
        // Change to Disconnect
        connectButton.innerHTML = '<span class="connection-status" id="connectionStatus"></span> Disconnect';
      } else {
        // Change to Connect
        connectButton.innerHTML = '<span class="connection-status" id="connectionStatus"></span> Connect';
      }
      
      // Update the connection status after changing the HTML
      updateConnectionStatus(isConnected ? 'connected' : 'disconnected');
    }

    // Connection Status Management
    function updateConnectionStatus(status) {
      const statusElement = document.getElementById('connectionStatus');
      statusElement.className = 'connection-status';
      
      switch(status) {
        case 'connected':
          statusElement.classList.add('connected');
          break;
        case 'connecting':
          statusElement.classList.add('connecting');
          break;
        case 'disconnected':
          // Default grey color (inactive)
          break;
      }
    }

    // WebSocket Management
    function setupWebSocket() {
      if (ws) ws.close();
      updateConnectionStatus('connecting');
      isConnected = false;
      updateConnectionButton();
      
      ws = new WebSocket(`ws://${ip}:8080/ws`);

      ws.onopen = () => {
        console.log("Connected to server");
        updateConnectionStatus('connected');
        isConnected = true;
        updateConnectionButton();
        
        // Automatically start video when connection is established
        const videoBtn = document.getElementById('videoBtn');
        if (videoBtn && !videoLoopInterval) {
          toggleVideoLoop(() => fetchImage('screenshot'), videoBtn, videoBtn.textContent.replace('Stop ', ''));
        }
      };
      
      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          console.log('WebSocket message received:', data);
          
          if (data.type === 'tokenUpdate') {
            document.getElementById('tokenCounter').textContent = data.total;
          } else if (data.type === 'taskUpdate') {
            handleTaskUpdate(data);
          } else {
            console.log('Unknown message type:', data.type);
          }
        } catch (error) {
          // Handle non-JSON messages or other WebSocket messages
          console.log('WebSocket message (non-JSON):', event.data);
        }
      };
      
      ws.onclose = () => {
        console.log("Disconnected from server");
        updateConnectionStatus('disconnected');
        isConnected = false;
        updateConnectionButton();
      };
      
      ws.onerror = (error) => {
        console.error("WebSocket error:", error);
        updateConnectionStatus('connecting'); // Show yellow for connection problems
        isConnected = false;
        updateConnectionButton();
      };
    }

    // Disconnect WebSocket
    function disconnectWebSocket() {
      if (ws) {
        ws.close();
        updateConnectionStatus('disconnected');
        isConnected = false;
        updateConnectionButton();
      }
      
      // Stop video stream when disconnecting
      if (videoLoopInterval) {
        clearInterval(videoLoopInterval);
        videoLoopInterval = null;
        
        // Reset video button texts
        const videoBtn = document.getElementById('videoBtn');
        const video2Btn = document.getElementById('video2');
        if (videoBtn) videoBtn.textContent = 'Video';
        if (video2Btn) video2Btn.textContent = 'Video 2';
      }
    }

    // Generic Functions
    function prettifyJSON(input) {
      try {
        return JSON.stringify(JSON.parse(input), null, 4);
      } catch {
        return input;
      }
    }

    function toggleVideoLoop(fetchFunction, button, buttonText) {
      if (videoLoopInterval) {
        clearInterval(videoLoopInterval);
        videoLoopInterval = null;
        button.textContent = buttonText;
        currentVideoSession = 0
      } else {
        currentVideoSession = button.id === 'videoBtn' ? 1 : button.id === 'video2' ? 2 : 0;
        videoLoopInterval = setInterval(fetchFunction, 1000 / currentFPS);
        button.textContent = `Stop ${buttonText}`;
      }
    }

    // FPS Selection Function
    function setFPS(fps) {
      currentFPS = fps;
      
      // Update button states
      document.querySelectorAll('.fps-button').forEach(btn => {
        if (parseInt(btn.dataset.fps) === fps) {
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      });
      
      // If video is currently streaming, restart it with new FPS
      if (videoLoopInterval) {
        // Find which video button is active and restart it
        const videoControls = {
          videoBtn: 'screenshot',
          video2: 'video2'
        };
        
        Object.entries(videoControls).forEach(([id, endpoint]) => {
          const btn = document.getElementById(id);
          if (btn && btn.textContent.includes('Stop')) {
            clearInterval(videoLoopInterval);
            videoLoopInterval = setInterval(() => fetchImage(endpoint), 1000 / currentFPS);
          }
        });
      }
      
      console.log(`FPS set to: ${currentFPS}`);
    }

    async function fetchImage(endpoint) {
      // Store session ID when request starts
      const thisSession = currentVideoSession;
      
      try {
        const response = await fetch(`http://${ip}:8080/${endpoint}`);
        if (!response.ok) throw new Error(`Failed to fetch ${endpoint}`);

        // Check if video was stopped while request was in flight
        if (thisSession !== currentVideoSession) {
          return; // Discard this image
        }

        const blob = await response.blob();
        const imageUrl = URL.createObjectURL(blob);
        if (screenshotImg.src) URL.revokeObjectURL(screenshotImg.src);
        screenshotImg.src = imageUrl;
        
        // Show image and hide placeholder
        screenshotImg.classList.remove('hidden');
        screenshotPlaceholder.classList.add('hidden');
      } catch (error) {
        console.error('Error:', error);
        // Show placeholder and hide image on error
        screenshotImg.classList.add('hidden');
        screenshotPlaceholder.classList.remove('hidden');
      }
    }

    // Mouse Functions
    async function sendMouseClick() {
      try {
        const response = await fetch(`http://${ip}:8080/mouse-click`);
        if (!response.ok) throw new Error('Failed to send mouse click');
      } catch (error) {
        console.error('Error:', error);
      }
    }

    async function sendMouseInput() {
      const x = document.getElementById('x-coord').value;
      const y = document.getElementById('y-coord').value;
      try {
        const response = await fetch(`http://${ip}:8080/mouse-input?x=${x}&y=${y}`);
        if (!response.ok) throw new Error('Failed to send mouse input');
      } catch (error) {
        console.error('Error:', error);
      }
    }

    function formatIp(ip) {
      if (ip.includes(':')) {
        return `[${ip}]`;
      } else {
        return `${ip}`;
      }
    }

    // Event Listeners
    document.getElementById("setTargetIP").addEventListener("click", () => {
      if (isConnected) {
        disconnectWebSocket();
      } else {
        ip = formatIp(document.getElementById('ipv4').value);
        console.log("Target IP changed to", ip);
        currentVideoSession += 1;
        setupWebSocket();
      }
    });

    // Toggle button event listener
    document.getElementById("toggleButtonsBtn").addEventListener("click", toggleMediaButtons);

    document.getElementById("screenshotBtn").addEventListener("click", () => fetchImage('screenshot'));
    document.getElementById("sendMouseClick").addEventListener("click", sendMouseClick);
    document.getElementById("sendMouseInput").addEventListener("click", sendMouseInput);

    // Video Controls
    const videoControls = {
      videoBtn: 'screenshot',
      video2: 'video2'
    };

    Object.entries(videoControls).forEach(([id, endpoint]) => {
      document.getElementById(id).addEventListener('click', function() {
        toggleVideoLoop(() => fetchImage(endpoint), this, this.textContent.replace('Stop ', ''));
      });
    });

    // Task Management Functions
    function createTaskCard(message, status = 'in-progress') {
      const taskCard = document.createElement('div');
      taskCard.className = `task-card ${status}`;
      
      const taskHeader = document.createElement('div');
      taskHeader.className = 'task-header';
      
      const taskStatus = document.createElement('span');
      taskStatus.className = 'task-status';
      taskStatus.textContent = status === 'in-progress' ? 'In Progress' : 
                             status === 'completed' ? 'Completed' :
                             status === 'broken' ? 'Broken' : 'Canceled';
      
      const cancelBtn = document.createElement('button');
      cancelBtn.className = 'task-cancel-btn';
      cancelBtn.textContent = 'Cancel';
      cancelBtn.addEventListener('click', () => {
        cancelTask(taskCard);
      });
      
      const taskMessage = document.createElement('div');
      taskMessage.className = 'task-message';
      taskMessage.textContent = message.length > 100 ? message.substring(0, 100) + '...' : message;
      
      taskHeader.appendChild(taskStatus);
      taskHeader.appendChild(cancelBtn);
      taskCard.appendChild(taskHeader);
      taskCard.appendChild(taskMessage);
      
      return taskCard;
    }
    
    function showTasksSection() {
      const tasksSection = document.getElementById('tasksSection');
      const chatFieldset = document.getElementById('chatFieldset');
      
      // Show tasks section with flexible sizing
      tasksSection.classList.add('visible');
      
      // Calculate dynamic flex value based on tasks content
      const tasksContainer = document.getElementById('tasksContainer');
      const taskCount = tasksContainer.children.length;
      const dynamicFlex = Math.max(1.5, 3 - (taskCount * 0.3)); // Adjust flex based on task count
      
      // Apply dynamic flex to chat section
      chatFieldset.style.flex = `${dynamicFlex}`;
    }
    
    function cancelTask(taskCard) {
      const taskId = taskCard.dataset.taskId;
      if (!taskId) return;
      
      // Send cancellation request to backend
      fetch(`http://${ip}:8080/task-cancel?taskId=${taskId}`)
        .then(response => response.json())
        .then(data => {
          console.log('Task cancellation response:', data);
          
          // Update UI based on backend response
          if (data.result === 'Task canceled successfully') {
            taskCard.classList.remove('in-progress');
            taskCard.classList.add('canceled');
            
            const statusElement = taskCard.querySelector('.task-status');
            statusElement.textContent = 'Canceled';
            
            // Remove cancel button
            const cancelBtn = taskCard.querySelector('.task-cancel-btn');
            if (cancelBtn) {
              cancelBtn.remove();
            }
            
            // Update current task status
            if (currentTask === taskCard) {
              currentTask = null;
            }
          }
        })
        .catch(error => {
          console.error('Error canceling task:', error);
        });
    }
    
    function handleTaskUpdate(data) {
      console.log('Task update received:', data);
      
      // Debug: Check if we have the expected data structure
      if (!data.taskId || !data.status) {
        console.error('Invalid task update data:', data);
        return;
      }
      
      const tasksContainer = document.getElementById('tasksContainer');
      const taskCards = tasksContainer.querySelectorAll('.task-card');
      
      // First, check if we have a pending task that needs to be updated with real task ID
      let taskCard = null;
      for (const card of taskCards) {
        if (card.dataset.taskId === 'pending') {
          // Found a pending task - update it with the real task ID
          card.dataset.taskId = data.taskId;
          
          // Enable cancel button now that we have a real task ID
          const cancelBtn = card.querySelector('.task-cancel-btn');
          if (cancelBtn) {
            cancelBtn.disabled = false;
            cancelBtn.textContent = 'Cancel';
          }
          
          taskCard = card;
          break;
        } else if (card.dataset.taskId === data.taskId) {
          taskCard = card;
          break;
        }
      }
      
      if (!taskCard) {
        // Create new task card if it doesn't exist
        taskCard = createTaskCard(data.message, data.status);
        taskCard.dataset.taskId = data.taskId;
        tasksContainer.appendChild(taskCard);
        
        // Show tasks section if it's the first task
        if (tasksContainer.children.length === 1) {
          showTasksSection();
        }
      } else {
        // Update existing task card
        console.log('Updating task card with status:', data.status);
        
        // Remove all status classes first
        taskCard.classList.remove('in-progress', 'completed', 'broken', 'canceled');
        // Add the new status class based on the status field
        taskCard.classList.add(data.status);
        
        const statusElement = taskCard.querySelector('.task-status');
        const messageElement = taskCard.querySelector('.task-message');
        
        if (statusElement) {
          statusElement.textContent = data.status === 'in-progress' ? 'In Progress' : 
                                    data.status === 'completed' ? 'Completed' :
                                    data.status === 'broken' ? 'Broken' : 'Canceled';
        }
        
        if (messageElement && data.message) {
          messageElement.textContent = data.message.length > 100 ? 
                                     data.message.substring(0, 100) + '...' : data.message;
        }
        
        // Remove cancel button if task is completed, broken, or canceled
        if (data.status !== 'in-progress') {
          const cancelBtn = taskCard.querySelector('.task-cancel-btn');
          if (cancelBtn) {
            cancelBtn.remove();
          }
        }
      }
      
      // Update current task reference
      if (data.status === 'in-progress') {
        currentTask = taskCard;
      } else if (currentTask === taskCard) {
        currentTask = null;
      }
    }

    function handleTaskCreation(message) {
      if (isFirstMessage) {
        // Create task card immediately for first message with temporary ID
        const tasksContainer = document.getElementById('tasksContainer');
        tasksContainer.innerHTML = ''; // Clear any existing tasks
        
        const taskCard = createTaskCard(message);
        taskCard.dataset.taskId = 'pending'; // Temporary ID until we get real one
        tasksContainer.appendChild(taskCard);
        currentTask = taskCard;
        
        // Disable cancel button until we get real task ID
        const cancelBtn = taskCard.querySelector('.task-cancel-btn');
        if (cancelBtn) {
          cancelBtn.disabled = true;
          cancelBtn.textContent = 'Cancel';
        }
        
        // Show tasks section
        showTasksSection();
        
        isFirstMessage = false;
      } else {
        // For subsequent messages, just send them as user help (no visual task card)
        console.log('User help message:', message);
      }
    }

    // LLM Chat
    document.getElementById("llmSendButton").addEventListener("click", () => {
      const inputText = document.getElementById('llmChatInput').value;
      if (!inputText) return;

      fetch(`http://${ip}:8080/llm-input`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text: inputText })
      }).catch(error => {
        console.error('Error:', error);
      });

      // Handle task creation
      handleTaskCreation(inputText);
      
      document.getElementById('llmChatInput').value = "";
    });

    // Hotkey functionality for chat input
    document.getElementById("llmChatInput").addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        if (event.shiftKey) {
          // Shift+Enter - allow default behavior (new line)
          return;
        } else {
          // Enter without Shift - send message if input is not empty
          event.preventDefault();
          const inputText = document.getElementById('llmChatInput').value.trim();
          if (inputText) {
            document.getElementById("llmSendButton").click();
          }
        }
      }
    });

    // Pop Out WS
    document.getElementById("popOutWSButton").addEventListener("click", function() {
      // Open window with specific features for better visibility
      popOutWSWindow = window.open('', '_blank', 'width=800,height=600,resizable=yes,scrollbars=yes');

      if (popOutWSWindow) {
        const html = `<!DOCTYPE html>
<html>
<head>
  <title>WebSocket Output</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      background-color: #1e1e1e;
      color: #fff;
      font-family: monospace;
    }
    #poppedTextarea {
      width: 100%;
      height: calc(100vh - 40px);
      background-color: #000;
      color: #fff;
      border: 1px solid #333;
      padding: 10px;
      font-size: 14px;
      line-height: 1.4;
      resize: none;
      box-sizing: border-box;
    }
  </style>
</head>
<body>
  <textarea id="poppedTextarea" readonly></textarea>
  <script>
    // Debug logging
    console.log('Pop-out window loaded');
    
    const ip = '${ip}';
    let ws = null;
    const textarea = document.getElementById('poppedTextarea');
    
    function log(msg) {
      console.log(msg);
      textarea.value += msg + '\\n';
      textarea.scrollTop = textarea.scrollHeight;
    }

    function setupWebSocket() {
      try {
        log('Attempting WebSocket connection...');
        
        ws = new WebSocket('ws://' + ip + ':8080/ws');
        
        ws.onopen = () => {
          log('Connected to WebSocket server');
        };
        
        ws.onmessage = (event) => {
          if (!event.data) return;
          
          try {
            const parsed = JSON.parse(event.data);
            const formatted = JSON.stringify(parsed, null, 2);
            log('Received: ' + formatted);
          } catch (e) {
            log('Received: ' + event.data);
          }
        };

        ws.onclose = () => {
          log('WebSocket connection closed');
          ws = null;
          // Try to reconnect after 3 seconds
          setTimeout(setupWebSocket, 3000);
        };

        ws.onerror = (error) => {
          log('WebSocket error: ' + error.message);
        };

      } catch (error) {
        log('Setup error: ' + error.message);
      }
    }

    // Start connection when window loads
    window.addEventListener('load', setupWebSocket);
  <\/script>
</body>
</html>`;

        // Write the HTML and explicitly close the document
        popOutWSWindow.document.open();
        popOutWSWindow.document.write(html);
        popOutWSWindow.document.close();

        // Log success in main window
        console.log('Pop-out window created successfully');
      } else {
        console.error('Failed to create pop-out window');
      }
    });
    
    // FPS Button Event Listeners
    document.querySelectorAll('.fps-button').forEach(button => {
      button.addEventListener('click', function() {
        const fps = parseInt(this.dataset.fps);
        setFPS(fps);
      });
    });

    // Initialize default FPS state
    setFPS(currentFPS);
    
    // Initial WebSocket setup for main window
    setupWebSocket();
    
    // Test function to verify task creation works
    function testTaskCreation() {
      console.log('Testing task creation...');
      handleTaskCreation('Test task message for demonstration purposes');
    }
    
    // Uncomment the line below to test the task creation functionality
    // testTaskCreation();
  </script>
</body>
</html>
