<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Screenshot App</title>
  <style>
    @font-face {
      font-family: 'JetBrains Mono';
      src: local('./fonts/webfonts/JetBrainsMono-Regular.woff2') format('woff2'),
           url('https://cdn.jsdelivr.net/gh/JetBrains/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2') format('woff2'),
           url('https://cdn.jsdelivr.net/gh/JetBrains/JetBrainsMono/web/woff/JetBrainsMono-Regular.woff') format('woff');
      font-display: swap;
      font-weight: 400;
      font-style: normal;
    }

    :root {
      --dot-bg: #000000de;
      --dot-color: #403f3f;
      --dot-size: 1px;
      --dot-space: 22px;
      --primary-bg: #212121;
      --border-color: #333333;
    }

    html, body {
      height: 100vh;
      width: 100vw;
      margin: 0;
      overflow: hidden;
      font-family: 'JetBrains Mono', monospace;
      color: white;
      background: linear-gradient(90deg, var(--dot-bg) calc(var(--dot-space) - var(--dot-size)), transparent 1%) center / var(--dot-space) var(--dot-space),
                  linear-gradient(var(--dot-bg) calc(var(--dot-space) - var(--dot-size)), transparent 1%) center / var(--dot-space) var(--dot-space),
                  var(--dot-color);
    }

    .main-wrapper {
      display: flex;
      height: 100vh;
      width: 100vw;
      gap: 20px;
      padding: 20px;
      box-sizing: border-box;
    }

    .toolbar {
      display: flex;
      flex-direction: column;
      width: 320px;
      min-width: 320px;
      gap: 10px;
      height: calc(100vh - 40px);
      /* overflow-y: auto; */
    }

    .main-content {
      flex: 1;
      min-width: 0;
      height: calc(100vh - 40px);
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
      grid-auto-rows: minmax(300px, 1fr);
      /* gap: 10px; */
      padding: 10px;
      overflow: auto;
    }

    .session-container {
      position: relative;
      background-color: rgba(0, 0, 0, 0.1);
      border: 1px solid var(--border-color);
      /* border-radius: 8px; */
      overflow: hidden;
      display: flex;
      flex-direction: column;
      transition: border-color 0.3s ease;
      -webkit-user-select: none; /* Safari */
      -moz-user-select: none; /* Firefox */
      -ms-user-select: none; /* IE10+/Edge */
      user-select: none; /* Standard */
    }

    .session-container * {
      -webkit-user-select: none; /* Safari */
      -moz-user-select: none; /* Firefox */
      -ms-user-select: none; /* IE10+/Edge */
      user-select: none; /* Standard */
    }

    .session-container.selected {
      position: relative;
      border-color: #4CAF50;
    }

    .session-container.selected::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: inherit;
      pointer-events: none;
      animation: waveBorder 2s ease-in-out infinite;
      z-index: 1;
    }

    .session-container.user-assist-selected {
      position: relative;
      border-color: #FFC107;
    }

    .session-container.user-assist-selected::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: inherit;
      pointer-events: none;
      animation: userAssistWaveBorder 2s ease-in-out infinite;
      z-index: 1;
    }

    @keyframes waveBorder {
      0% {
        border-width: 1px;
        box-shadow: 
          inset 0 0 2px rgba(76, 175, 80, 0.2),
          inset 0 0 4px rgba(76, 175, 80, 0.1);
      }
      25% {
        border-width: 1px;
        box-shadow: 
          inset 0 0 3px rgba(76, 175, 80, 0.3),
          inset 0 0 6px rgba(76, 175, 80, 0.15);
      }
      50% {
        border-width: 1px;
        box-shadow: 
          inset 0 0 4px rgba(76, 175, 80, 0.4),
          inset 0 0 8px rgba(76, 175, 80, 0.2);
      }
      75% {
        border-width: 1px;
        box-shadow: 
          inset 0 0 3px rgba(76, 175, 80, 0.3),
          inset 0 0 6px rgba(76, 175, 80, 0.15);
      }
      100% {
        border-width: 1px;
        box-shadow: 
          inset 0 0 2px rgba(76, 175, 80, 0.2),
          inset 0 0 4px rgba(76, 175, 80, 0.1);
      }
    }

    @keyframes userAssistWaveBorder {
      0% {
        border-width: 1px;
        box-shadow: 
          inset 0 0 2px rgba(255, 193, 7, 0.3),
          inset 0 0 4px rgba(255, 193, 7, 0.2);
      }
      25% {
        border-width: 1px;
        box-shadow: 
          inset 0 0 3px rgba(255, 193, 7, 0.4),
          inset 0 0 6px rgba(255, 193, 7, 0.25);
      }
      50% {
        border-width: 1px;
        box-shadow: 
          inset 0 0 4px rgba(255, 193, 7, 0.5),
          inset 0 0 8px rgba(255, 193, 7, 0.3);
      }
      75% {
        border-width: 1px;
        box-shadow: 
          inset 0 0 3px rgba(255, 193, 7, 0.4),
          inset 0 0 6px rgba(255, 193, 7, 0.25);
      }
      100% {
        border-width: 1px;
        box-shadow: 
          inset 0 0 2px rgba(255, 193, 7, 0.3),
          inset 0 0 4px rgba(255, 193, 7, 0.2);
      }
    }

    .session-header {
      background-color: var(--primary-bg);
      padding: 8px 12px;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 12px;
      color: #6f6f6f;
    }

    .session-close {
      background: none;
      border: none;
      color: #ff6b6b;
      cursor: pointer;
      font-size: 14px;
      padding: 2px 6px;
      border-radius: 3px;
    }

    .session-close:hover {
      background-color: rgba(255, 107, 107, 0.1);
    }

    .session-content {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
      min-height: 0;
      overflow: hidden; /* Prevent content from overflowing */
    }

    /* Layout adjustments for different session counts */
    .main-content[data-session-count="1"] {
      grid-template-columns: 1fr;
    }

    .main-content[data-session-count="2"] {
      grid-template-columns: 1fr 1fr;
    }

    .main-content[data-session-count="3"] {
      grid-template-columns: 1fr 1fr;
      grid-template-rows: 1fr 1fr;
    }

    .main-content[data-session-count="3"] .session-container:nth-child(3) {
      grid-column: span 2;
    }

    .main-content[data-session-count="4"] {
      grid-template-columns: 1fr 1fr;
      grid-template-rows: 1fr 1fr;
    }

    .main-content[data-session-count="5"] {
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(2, 1fr);
    }

    .main-content[data-session-count="5"] .session-container:nth-child(5) {
      grid-column: span 3;
    }

    .main-content[data-session-count="6"] {
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(2, 1fr);
    }

    .button-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .control-button {
      background-color: rgb(1, 1, 1);
      border: 1px solid var(--border-color);
      color: #6f6f6f;
      padding: 12px;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s ease;
      width: 100%;
      text-align: left;
    }

    .control-button:hover {
      background-color: #010b13;
    }

    .screenshot-img {
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
      object-fit: contain;
      flex-shrink: 0;
    }

    .input-group {
      display: flex;
      gap: 8px;
      width: 100%;
    }

    .coord-inputs {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .coord-input {
      width: 60px;
      padding: 6px;
      background: var(--primary-bg);
      border: 1px solid var(--border-color);
      color: white;
      border-radius: 4px;
    }

    .dark-textarea {
      background-color: var(--primary-bg);
      color: white;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 10px;
      resize: none;
      width: 100%;
      box-sizing: border-box;
    }

    #llmChatInput {
      height: 100%;
      margin-top: 0px;
    }

    #llmChatInput:focus {
      outline: none;
    }

    fieldset {
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 10px;
      margin: 0;
      position: relative;
    }

    fieldset legend {
      cursor: default;
      -webkit-user-select: none; /* Safari */
      -moz-user-select: none; /* Firefox */
      -ms-user-select: none; /* IE10+/Edge */
      user-select: none; /* Standard */
    }

    #colorsList ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    #colorsList li {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }

    .color-square {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      border: 1px solid var(--border-color);
    }

    .scrollable {
      overflow-y: auto;
      flex: 1;
      min-height: 0;
    }

    /* Connection Status Indicator */
    .connection-status {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 8px;
      background-color: #666; /* Grey - inactive */
    }

    .connection-status.connected {
      background-color: #4CAF50; /* Green - connected */
      box-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
    }

    .connection-status.connecting {
      background-color: #FFC107; /* Yellow - connecting/error */
      box-shadow: 0 0 5px rgba(255, 193, 7, 0.5);
    }

    .connection-button {
      display: flex;
      align-items: center;
    }

    /* Hidden button group */
    .button-group.hidden {
      display: none;
    }

    /* Small toggle button */
    .toggle-buttons-btn {
      position: fixed;
      top: 5px;
      left: 5px;
      width: 10px;
      height: 10px;
      background-color: black; /* #333; */
      border: 1px solid #555;
      border-radius: 50%;
      cursor: pointer;
      z-index: 1000;
      padding: 0;
      margin: 0;
    }

    .toggle-buttons-btn:hover {
      background-color: #444;
    }

    /* FPS Button Styles */
    .fps-button {
      background-color: rgb(1, 1, 1);
      border: 1px solid var(--border-color);
      color: #6f6f6f;
      padding: 2px 6px;
      border-radius: 3px;
      cursor: pointer;
      transition: background-color 0.3s ease;
      font-size: 11px;
      height: 20px;
      min-width: 24px;
      flex: 1;
      text-align: center;
    }

    .fps-button:hover {
      background-color: #010b13;
    }

    .fps-button.active {
      background-color: #2a2a2a;
      color: #ffffff;
      border-color: #555555;
    }

    /* Debug Button Styles */
    .debug-button {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 10px;
      height: 10px;
      background-color: black;
      border: 1px solid #555;
      border-radius: 50%;
      cursor: pointer;
      padding: 0;
      margin: 0;
      z-index: 1;
    }

    .debug-button:hover {
      background-color: #444;
    }

    /* Screenshot placeholder styles */
    .screenshot-placeholder {
      display: flex;
      justify-content: center;
      align-items: center;
      color: #6f6f6f;
      font-size: 14px;
      text-align: center;
      width: 100%;
      height: 100%;
    }
    
    .screenshot-img.hidden {
      display: none;
    }
    
    .screenshot-placeholder.hidden {
      display: none;
    }

    /* Task Management Styles */
    .tasks-section {
      display: none;
      flex-direction: column;
      gap: 10px;
      transition: all 0.3s ease;
    }
    
    .tasks-section.visible {
      display: flex;
      flex: 1;
      max-height: fit-content;
      opacity: 1;
      transform: translateY(0);
    }
    
    .tasks-section fieldset {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
      overflow: hidden;
      padding-right: 0px;
      padding-bottom: 0px;
      padding-top: 0px;
      padding-left: 0px;
    }
    
    .tasks-section fieldset legend {
      margin-left: 10px;
    }
    
    .tasks-section {
      min-height: 0;
      max-height: 50vh; /* Limit maximum height to 50% of viewport */
    }
    
    /* Ensure tasks container is scrollable */
    #tasksContainer {
      overflow-y: auto;
      flex: 1;
      min-height: 0;
      padding: 15px;
      
      /* Custom scrollbar styling */
      scrollbar-width: thin;
      scrollbar-color: #555 #212121;
    }
    
    /* Webkit browsers (Chrome, Safari, Edge) */
    #tasksContainer::-webkit-scrollbar {
      width: 6px;
    }
    
    #tasksContainer::-webkit-scrollbar-track {
      background: #212121;
      border-radius: 3px;
    }
    
    #tasksContainer::-webkit-scrollbar-thumb {
      background: #444;
      border-radius: 3px;
    }
    
    #tasksContainer::-webkit-scrollbar-thumb:hover {
      background: #666;
    }
    
    /* Firefox */
    #tasksContainer {
      scrollbar-width: thin;
      scrollbar-color: #444 #212121;
    }

    .tasks-section.visible {
      max-height: fit-content;
      opacity: 1;
      transform: translateY(0);
    }

    .task-card {
      background-color: var(--primary-bg);
      border: 2px solid;
      border-radius: 8px;
      padding: 12px;
      position: relative;
      animation: waveOutline 3s ease-in-out infinite;
      transition: all 0.3s ease;
      margin-top: 4px;
      margin-bottom: 4px;
      cursor: default;
    }

    @keyframes waveOutline {
      0% {
        box-shadow: 0 0 5px currentColor, 0 0 10px rgba(255, 255, 255, 0.1);
        border-color: currentColor;
      }
      50% {
        box-shadow: 0 0 20px currentColor, 0 0 30px rgba(255, 255, 255, 0.2);
        border-color: rgba(255, 255, 255, 0.8);
      }
      100% {
        box-shadow: 0 0 5px currentColor, 0 0 10px rgba(255, 255, 255, 0.1);
        border-color: currentColor;
      }
    }

    .task-card.in-progress {
      border-color: #FFC107;
      color: #FFC107;
    }

    .task-card.completed {
      border-color: #4CAF50;
      color: #4CAF50;
    }

    .task-card.broken {
      border-color: #F44336;
      color: #F44336;
    }

    .task-card.canceled {
      border-color: #9E9E9E;
      color: #9E9E9E;
    }

    .task-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      gap: 8px;
    }
    
    .task-header-left {
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 1;
    }
    
    .task-header-controls {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .task-status {
      font-size: 12px;
      font-weight: bold;
      text-transform: uppercase;
    }

    .task-cancel-btn {
      background: none;
      border: 1px solid currentColor;
      color: currentColor;
      border-radius: 4px;
      padding: 4px 8px;
      cursor: pointer;
      font-size: 11px;
      transition: all 0.2s ease;
    }

    .task-cancel-btn:hover:not(:disabled) {
      /* background-color: currentColor; */
      color: white;
    }

    .task-cancel-btn:disabled {
      cursor: not-allowed;
      opacity: 0.6;
    }

    .task-message {
      font-size: 12px;
      line-height: 1.4;
      word-wrap: break-word;
      max-height: 60px;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Session window icon for opening session window - made more transparent */
    .task-session-window-icon {
      width: 16px;
      height: 16px;
      background-color: rgba(85, 85, 85, 0.2); /* Increased transparency from 0.3 to 0.2 */
      color: rgba(255, 255, 255, 0.5); /* Increased transparency from 0.6 to 0.5 */
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: bold;
      cursor: pointer;
      border: 1px solid rgba(255, 255, 255, 0.08); /* Increased transparency from 0.1 to 0.08 */
      border-radius: 3px;
      transition: all 0.2s ease;
    }

    .task-session-window-icon:hover {
      background-color: rgba(119, 119, 119, 0.5); /* Increased transparency from 0.7 to 0.5 */
      transform: scale(1.05);
    }
    
    /* Timer for in-progress tasks */
    .task-timer {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 11px;
      color: #FFC107;
    }

    /* Info icon for completed, broken, and canceled tasks - made more transparent */
    .task-info-icon {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background-color: rgba(85, 85, 85, 0.2); /* Increased transparency from 0.3 to 0.2 */
      color: rgba(255, 255, 255, 0.4); /* Increased transparency from 0.5 to 0.4 */
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: bold;
      cursor: default;
      border: 1px solid rgba(255, 255, 255, 0.08); /* Increased transparency from 0.1 to 0.08 */
      transition: all 0.2s ease;
    }

    .task-info-icon:hover {
      background-color: rgba(119, 119, 119, 0.3); /* Increased transparency from 0.4 to 0.3 */
      transform: scale(1.05);
    }

    /* Timer colors for different statuses */
    .task-card.completed .task-timer {
      color: #66BB6A; /* Lighter green */
    }

    .task-card.broken .task-timer {
      color: #EF5350; /* Lighter red */
    }

    .task-card.canceled .task-timer {
      color: #BDBDBD; /* Lighter gray */
    }

    .sandwatch-icon {
      font-size: 12px;
    }


    .chat-fieldset.shrunk {
      /* flex: 1.5 !important; */
      flex: 1 !important;
      transition: flex 0.3s ease;
    }

    /* Screenshot container and overlay styles */
    .screenshot-container {
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      max-width: 100%;
      max-height: 100%;
      /* width: 100%; */
      height: 100%;
    }

    /* Invisible container that matches image size exactly */
    .image-size-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none; /* Allow clicks to pass through to the image */
    }

    .screenshot-overlay {
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      height: 30px;
      background-color: rgba(0, 0, 0, 0.3); /* More transparent (30% instead of 85%) */
      display: flex;
      align-items: center;
      justify-content: flex-end;
      padding: 0 10px;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none; /* Allow clicks to pass through to the image */
      width: 100%; /* Use full width of the invisible container */
      z-index: 1000; /* Ensure it's above the image */
    }
    
    /* Fullscreen mode - overlay should span full width */
    .screenshot-container:fullscreen .screenshot-overlay,
    .screenshot-container:-webkit-full-screen .screenshot-overlay,
    .screenshot-container:-moz-full-screen .screenshot-overlay,
    .screenshot-container:-ms-fullscreen .screenshot-overlay {
      position: fixed !important; /* Make overlay fixed to viewport in fullscreen */
      width: 100vw !important; /* Force full screen width */
      left: 0 !important;
      bottom: 0 !important;
      transform: none !important;
      justify-content: flex-end;
      padding-right: 20px;
      z-index: 9999; /* Ensure it's above everything */
    }
    
    /* Fullscreen mode - make image-size-container span full width */
    .screenshot-container:fullscreen .image-size-container,
    .screenshot-container:-webkit-full-screen .image-size-container,
    .screenshot-container:-moz-full-screen .image-size-container,
    .screenshot-container:-ms-fullscreen .image-size-container {
      width: 100% !important; /* Use percentage instead of viewport units */
      height: 100% !important;
      position: absolute !important;
      top: 0 !important;
      left: 0 !important;
      transform: none !important; /* Reset transform for fullscreen */
    }
    
    /* Fix positioning to ensure overlay is at the bottom of the image */
    .screenshot-container {
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    .screenshot-img {
      display: block; /* Ensure image is treated as a block element */
    }
    

    .fullscreen-button {
      background: none;
      border: none;
      color: white;
      cursor: pointer;
      padding: 4px;
      border-radius: 3px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background-color 0.2s ease;
    }

    .fullscreen-button:hover {
      background-color: rgba(255, 255, 255, 0.2);
    }

    .fullscreen-button svg {
      width: 16px;
      height: 16px;
    }

    .screenshot-container.focused .screenshot-overlay {
      opacity: 1;
      pointer-events: auto;
    }
    
    /* Remove focus outline from screenshot container */
    .screenshot-container:focus {
      outline: none !important;
    }
    
    .screenshot-container.focused {
      outline: none !important;
    }

    /* Fullscreen styling - center image and make it fit content */
    .screenshot-container:fullscreen {
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: black;
      width: 100vw;
      height: 100vh;
    }
    
    .screenshot-container:fullscreen .screenshot-img {
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
      object-fit: contain;
    }
    
    /* Vendor prefixes for fullscreen */
    .screenshot-container:-webkit-full-screen {
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: black;
      width: 100vw;
      height: 100vh;
    }
    
    .screenshot-container:-webkit-full-screen .screenshot-img {
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
      object-fit: contain;
    }
    
    .screenshot-container:-moz-full-screen {
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: black;
      width: 100vw;
      height: 100vh;
    }
    
    .screenshot-container:-moz-full-screen .screenshot-img {
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
      object-fit: contain;
    }
    
    .screenshot-container:-ms-fullscreen {
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: black;
      width: 100vw;
      height: 100vh;
    }
    
    .screenshot-container:-ms-fullscreen .screenshot-img {
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
      object-fit: contain;
    }

  </style>
  
  <!-- Toast notification styles -->
  <style>
    .toast-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 10000;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .toast {
      background-color: #f44336;
      color: white;
      padding: 12px 20px;
      border-radius: 4px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      display: flex;
      align-items: center;
      justify-content: space-between;
      min-width: 300px;
      max-width: 400px;
      animation: toastSlideIn 0.3s ease-out;
      transition: opacity 0.3s ease;
    }
    
    .toast.success {
      background-color: #4CAF50;
    }
    
    .toast.warning {
      background-color: #FFC107;
      color: #333;
    }
    
    .toast.info {
      background-color: #2196F3;
    }
    
    .toast-content {
      flex: 1;
      font-size: 14px;
      line-height: 1.4;
    }
    
    .toast-close {
      background: none;
      border: none;
      color: inherit;
      cursor: pointer;
      margin-left: 10px;
      font-size: 16px;
      opacity: 0.7;
      transition: opacity 0.2s ease;
    }
    
    .toast-close:hover {
      opacity: 1;
    }
    
    @keyframes toastSlideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
    
    .toast.fade-out {
      opacity: 0;
      transform: translateX(100%);
    }
  </style>
  
  <!-- Connection line styles -->
  <style>
    .connection-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 100;
    }
    
    .connection-path {
      fill: none;
      stroke-width: 2;
      stroke-linecap: round;
      stroke-linejoin: round;
    }
    
    .connection-path.pulsating {
      animation: connectionPulse 4s ease-in-out infinite;
      stroke-dasharray: 5, 5;
    }
    
    .pulse-dot {
      fill: #4CAF50;
      animation: pulseTravel 2.5s linear infinite;
      opacity: 0;
    }
    
    @keyframes connectionPulse {
      0%, 100% {
        stroke: #4CAF50;
        stroke-width: 1;
        opacity: 0.6;
      }
      50% {
        stroke: #66BB6A;
        stroke-width: 1.5;
        opacity: 0.8;
      }
    }
    
    @keyframes pulseTravel {
      0% {
        opacity: 0;
        transform: translateX(-10px);
      }
      10% {
        opacity: 1;
      }
      90% {
        opacity: 1;
      }
      100% {
        opacity: 0;
        transform: translateX(10px);
      }
    }
    
    .connection-start {
      position: absolute;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background-color: #4CAF50;
      animation: startPulse 2s ease-in-out infinite;
      z-index: 101;
      pointer-events: none;
    }
    
    .connection-end {
      position: absolute;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background-color: #4CAF50;
      border: 2px solid #00ff88;
      animation: endPulse 1.5s ease-in-out infinite;
      z-index: 101;
      pointer-events: none;
    }
    
    @keyframes startPulse {
      0%, 100% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7);
      }
      50% {
        transform: scale(1.2);
        box-shadow: 0 0 0 8px rgba(76, 175, 80, 0);
      }
    }
    
    @keyframes endPulse {
      0%, 100% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(0, 255, 136, 0.7);
      }
      50% {
        transform: scale(1.1);
        box-shadow: 0 0 0 6px rgba(0, 255, 136, 0);
      }
    }

    /* User-assist connection line styles */
    .connection-path.user-assist {
      animation: userAssistPulse 4s ease-in-out infinite;
      stroke-dasharray: 5, 5;
    }
    
    .pulse-dot.user-assist {
      fill: #FFC107;
      animation: userAssistPulseTravel 2.5s linear infinite;
    }
    
    @keyframes userAssistPulse {
      0%, 100% {
        stroke: #FFC107;
        stroke-width: 1;
        opacity: 0.6;
      }
      50% {
        stroke: #FFD54F;
        stroke-width: 1.5;
        opacity: 0.8;
      }
    }
    
    @keyframes userAssistPulseTravel {
      0% {
        opacity: 0;
        transform: translateX(-10px);
      }
      10% {
        opacity: 1;
      }
      90% {
        opacity: 1;
      }
      100% {
        opacity: 0;
        transform: translateX(10px);
      }
    }

    /* User-assist badge styles - centered sticker on top of chat fieldset */
    .chat-fieldset {
      position: relative;
    }
    
    .user-assist-badge {
      display: inline-block;
      background-color: #FFC107;
      color: #333;
      font-size: 12px;
      font-weight: bold;
      padding: 2px 8px;
      border-radius: 10px;
      animation: badgePulse 2s ease-in-out infinite;
      position: absolute;
      /* top: -10px; */
      top: 0px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
    }
    
    /* Restore original legend styling */
    .chat-fieldset legend {
      position: static;
    }
    
    @keyframes badgePulse {
      0%, 100% {
        box-shadow: 0 0 5px rgba(255, 193, 7, 0.5);
      }
      50% {
        box-shadow: 0 0 10px rgba(255, 193, 7, 0.8);
      }
    }

    /* User-assist chat input color */
    .chat-fieldset.user-assist-active legend {
      color: #FFC107;
    }
    
    #llmChatInput.user-assist-active {
      background-color: rgba(255, 193, 7, 0.1);
      border-color: rgba(255, 193, 7, 0.3);
    }
    
    #llmChatInput.user-assist-active:focus {
      border-color: rgba(255, 193, 7, 0.5);
      box-shadow: 0 0 0 2px rgba(255, 193, 7, 0.2);
    }
  </style>
</head>
<body>
  <div class="main-wrapper">
    <div class="toolbar">
      <div class="button-group hidden" id="mediaButtonsGroup">
        <button class="control-button" id="screenshotBtn">Take Screenshot</button>
        <button class="control-button" id="videoBtn">Video</button>
        <button class="control-button" id="video2">Video 2</button>
        <button class="control-button" id="popOutWSButton">Pop Out WS</button>
        
        <fieldset>
          <legend>Mouse Control</legend>
          <div class="coord-inputs">
            <input type="text" id="x-coord" class="coord-input"
                   placeholder="X"
                   pattern="-?[0-9]+"
                   title="Please enter a valid coordinate value."
                   oninput="this.value = this.value.replace(/[^-0-9]/g, '')" required>
            <input type="text" id="y-coord" class="coord-input"
                   placeholder="Y"
                   pattern="-?[0-9]+"
                   title="Please enter a valid coordinate value."
                   oninput="this.value = this.value.replace(/[^-0-9]/g, '')" required>
            <button class="control-button" id="sendMouseInput">Move</button>
            <button class="control-button" id="sendMouseClick">Click</button>
          </div>
        </fieldset>
      </div>

      <fieldset>
        <legend>Connection</legend>
        
        <!-- Debug Button positioned at top right -->
        <button class="debug-button" id="toggleButtonsBtn" title="Debug"></button>
        
        <!-- FPS Selection -->
        <div class="fps-selector" style="margin-bottom: 10px;">
          <label style="display: block; margin-bottom: 4px; font-size: 12px; color: #6f6f6f;">FPS</label>
          <div class="fps-buttons" style="display: flex; gap: 4px; height: 20px;">
            <button class="fps-button" data-fps="1">1</button>
            <button class="fps-button" data-fps="5">5</button>
            <button class="fps-button" data-fps="10">10</button>
            <button class="fps-button" data-fps="15">15</button>
            <button class="fps-button" data-fps="30">30</button>
          </div>
        </div>

        <div class="input-group">
          <input type="text" id="ipv4" class="dark-textarea" 
                 placeholder="IP Address" 
                 pattern="^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$|^[\da-fA-F:]+$"
                 oninput="this.value=this.value.replace(/[^0-9a-fA-F.:]/g,'')" required>
          <button class="control-button" id="setTargetIP">Connect</button>
        </div>
        
      </fieldset>

      <fieldset>
        <legend>Status</legend>
        <p style="margin: auto; font-size: 12px; padding: 5px; width: fit-content;">Total tokens used: <span id="tokenCounter">0</span></p>
        <p style="margin: auto; font-size: 12px; padding: 5px; width: fit-content;">Total network data usage: <span id="networkCounter">0</span></p>
      </fieldset>

      <div id="tasksSection" class="tasks-section">
        <fieldset>
          <legend>Tasks</legend>
          <div id="tasksContainer"></div>
        </fieldset>
      </div>

      <fieldset id="chatFieldset" style="flex: 3; display: flex; flex-direction: column; min-height: 200px;" class="chat-fieldset">
        <legend>Chat</legend>
        <textarea id="llmChatInput" class="dark-textarea" placeholder="Type a message..." spellcheck="false" autocorrect="off" autocapitalize="off" autocomplete="off"></textarea>
        <button class="control-button" id="llmSendButton" style="margin-top: 10px;">Send</button>
      </fieldset>
    </div>

    <div class="main-content" id="mainContent" data-session-count="0">
      <!-- Session containers will be dynamically added here -->
    </div>
    
    <!-- Connection overlay for drawing lines between chat and sessions -->
    <div class="connection-overlay" id="connectionOverlay">
      <svg width="100%" height="100%" id="connectionSvg"></svg>
    </div>
  </div>

  <!-- Toast notification container -->
  <div class="toast-container" id="toastContainer"></div>

  <script>
    // Global variables
    let popOutWSWindow = null;
    // Task Management
    let currentTask = null;
    let isFirstMessage = true;
    
    // Network data tracking - per session tracking
    let totalNetworkBytes = 0;
    let networkMutex = false;
    let sessionNetworkData = new Map(); // Map to track network data per session
    let lastUpdateTime = Date.now();
    
    // Function to format network data usage
    function formatNetworkBytes(bytes) {
        if (bytes < 1024) {
            return `${bytes} B`;
        } else if (bytes < 1024 * 1024) {
            return `${(bytes / 1024).toFixed(2)} KB`;
        } else if (bytes < 1024 * 1024 * 1024) {
            return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
        } else {
            return `${(bytes / (1024 * 1024 * 1024)).toFixed(2)} GB`;
        }
    }
    
    // Function to track network data for a specific session
    function trackSessionNetworkData(sessionId, bytes) {
        if (networkMutex) return;
        networkMutex = true;
        
        // Initialize session data if it doesn't exist
        if (!sessionNetworkData.has(sessionId)) {
            sessionNetworkData.set(sessionId, {
                totalBytes: 0,
                lastUpdate: Date.now()
            });
        }
        
        const sessionData = sessionNetworkData.get(sessionId);
        sessionData.totalBytes += bytes;
        sessionNetworkData.set(sessionId, sessionData);
        
        // Update total network bytes
        totalNetworkBytes += bytes;
        
        // Update display immediately for real-time feedback
        updateNetworkCounter();
        
        networkMutex = false;
    }
    
    // Function to update network counter display
    function updateNetworkCounter() {
        const networkCounter = document.getElementById('networkCounter');
        if (networkCounter) {
            networkCounter.textContent = formatNetworkBytes(totalNetworkBytes);
        }
    }
    
    // Function to reset network counter
    function resetNetworkCounter() {
        totalNetworkBytes = 0;
        sessionNetworkData.clear();
        lastUpdateTime = Date.now();
        const networkCounter = document.getElementById('networkCounter');
        if (networkCounter) {
            networkCounter.textContent = '0 B';
        }
    }
    
    // Function to get network usage for a specific session
    function getSessionNetworkUsage(sessionId) {
        if (sessionNetworkData.has(sessionId)) {
            return sessionNetworkData.get(sessionId).totalBytes;
        }
        return 0;
    }
    
    // Function to get total network usage across all sessions
    function getTotalNetworkUsage() {
        return totalNetworkBytes;
    }
    
    // Toast notification functionality
    function showToast(message, type = 'error', duration = 4000) {
      const toastContainer = document.getElementById('toastContainer');
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      
      const toastContent = document.createElement('div');
      toastContent.className = 'toast-content';
      toastContent.textContent = message;
      
      const closeButton = document.createElement('button');
      closeButton.className = 'toast-close';
      closeButton.innerHTML = '×';
      closeButton.addEventListener('click', () => {
        removeToast(toast);
      });
      
      toast.appendChild(toastContent);
      toast.appendChild(closeButton);
      toastContainer.appendChild(toast);
      
      // Auto-remove after duration unless hovered
      let timeoutId = setTimeout(() => {
        removeToast(toast);
      }, duration);
      
      // Reset timer on hover
      toast.addEventListener('mouseenter', () => {
        clearTimeout(timeoutId);
      });
      
      // Restart timer when mouse leaves
      toast.addEventListener('mouseleave', () => {
        timeoutId = setTimeout(() => {
          removeToast(toast);
        }, duration);
      });
    }
    
    function removeToast(toast) {
      toast.classList.add('fade-out');
      setTimeout(() => {
        if (toast.parentNode) {
          toast.parentNode.removeChild(toast);
        }
      }, 300);
    }
    
    // Remove old screenshot elements since we're using dynamic sessions
    const oldScreenshotImg = document.getElementById('screenshotImg');
    const oldScreenshotPlaceholder = document.getElementById('screenshotPlaceholder');
    if (oldScreenshotImg && oldScreenshotPlaceholder) {
      oldScreenshotImg.remove();
      oldScreenshotPlaceholder.remove();
    }
    

    // Toggle debug options functionality
    let debugOptionsVisible = false;
    function toggleDebugOptions() {
      const mediaButtonsGroup = document.getElementById('mediaButtonsGroup');
      debugOptionsVisible = !debugOptionsVisible;
      
      if (debugOptionsVisible) {
        mediaButtonsGroup.classList.remove('hidden');
      } else {
        mediaButtonsGroup.classList.add('hidden');
      }
    }

    function formatIp(ip) {
      if (ip.includes(':')) {
        return `[${ip}]`;
      } else {
        return `${ip}`;
      }
    }

    // Multi-session management
    const sessions = new Map();
    const mainContent = document.getElementById('mainContent');
    let currentFPS = 5; // Default FPS
    let selectedSessionId = null;

    // Function to select a session and apply wave animation
    function selectSession(sessionId) {
      console.log(`Attempting to select session: ${sessionId}`);
      
      // Remove selected class from all sessions
      document.querySelectorAll('.session-container').forEach(container => {
        container.classList.remove('selected', 'user-assist-selected');
      });
      
      // Add selected class to the chosen session
      const session = sessions.get(sessionId);
      if (session && session.container) {
        console.log(`Found session, adding selected class to container`);
        
        // Apply appropriate styling based on user-assist mode
        if (userAssistActive && userAssistTaskCard) {
          const taskSessionId = userAssistTaskCard.dataset.sessionId;
          if (taskSessionId === sessionId) {
            // This is the user-assist session - apply golden yellow/orange styling
            session.container.classList.add('user-assist-selected');
            console.log(`Applied user-assist styling to session: ${sessionId}`);
          } else {
            // User manually selected a different session while user-assist is active
            console.log('User manually selected different session, deactivating user-assist');
            deactivateUserAssist();
            session.container.classList.add('selected');
          }
        } else {
          // Normal selection - apply green styling
          session.container.classList.add('selected');
        }
        
        selectedSessionId = sessionId;
        console.log(`Selected session: ${sessionId}`);
      } else {
        console.log(`Session not found or container missing for sessionId: ${sessionId}`);
        console.log(`Available sessions:`, Array.from(sessions.keys()));
      }
    }

    // Function to get the currently selected session
    function getSelectedSession() {
      return selectedSessionId ? sessions.get(selectedSessionId) : null;
    }

    // Create a new session
    function createSession(ipAddress) {
      const sessionId = ipAddress;
      
      if (sessions.has(sessionId)) {
        console.log(`Session ${sessionId} already exists`);
        return sessions.get(sessionId);
      }

      // Create session container
      const sessionContainer = document.createElement('div');
      sessionContainer.className = 'session-container';
      sessionContainer.dataset.sessionId = sessionId;

      // Create session header
      const sessionHeader = document.createElement('div');
      sessionHeader.className = 'session-header';
      
      // Create status indicator
      const statusIndicator = document.createElement('span');
      statusIndicator.className = 'connection-status';
      
      const sessionTitle = document.createElement('span');
      sessionTitle.textContent = `Session: ${sessionId}`;
      
      const closeButton = document.createElement('button');
      closeButton.className = 'session-close';
      closeButton.innerHTML = '×';
      closeButton.title = 'Close session';
      closeButton.addEventListener('click', () => {
        closeSession(sessionId);
      });

      sessionHeader.appendChild(statusIndicator);
      sessionHeader.appendChild(sessionTitle);
      sessionHeader.appendChild(closeButton);

      // Create session content
      const sessionContent = document.createElement('div');
      sessionContent.className = 'session-content';

      // Create screenshot placeholder
      const placeholder = document.createElement('div');
      placeholder.className = 'screenshot-placeholder';
      placeholder.textContent = 'Video stream will appear here';

      // Create screenshot image
      const screenshotImg = document.createElement('img');
      screenshotImg.className = 'screenshot-img hidden';
      screenshotImg.alt = `Video stream from ${sessionId}`;

      // Create screenshot container
      const screenshotContainer = document.createElement('div');
      screenshotContainer.className = 'screenshot-container';

      // Create image size container and overlay
      const imageSizeContainer = document.createElement('div');
      imageSizeContainer.className = 'image-size-container';

      const screenshotOverlay = document.createElement('div');
      screenshotOverlay.className = 'screenshot-overlay';

      // Create maximize button (different icon from fullscreen)
      const maximizeBtn = document.createElement('button');
      maximizeBtn.className = 'fullscreen-button';
      maximizeBtn.title = 'Maximize session (M)';
      maximizeBtn.innerHTML = `
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"></path>
        </svg>
      `;

      const fullscreenBtn = document.createElement('button');
      fullscreenBtn.className = 'fullscreen-button';
      fullscreenBtn.title = 'Toggle fullscreen (F)';
      fullscreenBtn.innerHTML = `
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
        </svg>
      `;

      screenshotOverlay.appendChild(maximizeBtn);
      screenshotOverlay.appendChild(fullscreenBtn);
      imageSizeContainer.appendChild(screenshotOverlay);
      screenshotContainer.appendChild(screenshotImg);
      screenshotContainer.appendChild(imageSizeContainer);
      
      sessionContent.appendChild(placeholder);
      sessionContent.appendChild(screenshotContainer);
      
      sessionContainer.appendChild(sessionHeader);
      sessionContainer.appendChild(sessionContent);

      // Add to main content
      mainContent.appendChild(sessionContainer);

      // Add click event listener to select session
      sessionContainer.addEventListener('click', () => {
        selectSession(sessionId);
      });

      // Create session object
      const session = {
        id: sessionId,
        ip: ipAddress,
        ws: null,
        container: sessionContainer,
        content: sessionContent,
        img: screenshotImg,
        placeholder: placeholder,
        screenshotContainer: screenshotContainer,
        fullscreenBtn: fullscreenBtn,
        videoInterval: null,
        isConnected: false
      };
      
      sessions.set(sessionId, session);
      updateSessionLayout();

      // Automatically select the newly created session
      selectSession(sessionId);

      // Add fullscreen functionality for this session
      setupSessionFullscreen(session);

      return session;
    }

    // Close a session
    function closeSession(sessionId) {
      const session = sessions.get(sessionId);
      if (!session) return;

      // Check if the session being closed is maximized
      const isMaximized = session.container.classList.contains('maximized');
      
      // Check if the session being closed is the currently selected one
      const isSelectedSession = selectedSessionId === sessionId;
      
      // Disconnect WebSocket if connected
      if (session.ws) {
        session.ws.close();
      }

      // Stop video stream
      if (session.videoInterval) {
        clearInterval(session.videoInterval);
      }

      // Remove from DOM
      if (session.container && session.container.parentNode) {
        session.container.parentNode.removeChild(session.container);
      }

      // Remove from sessions map
      sessions.delete(sessionId);
      
      // If the closed session was maximized, restore other sessions
      if (isMaximized) {
        sessions.forEach((otherSession, otherSessionId) => {
          otherSession.container.style.display = 'flex';
        });
      }
      
      // If the closed session was the selected one, select another session if available
      if (isSelectedSession && sessions.size > 0) {
        // Use setTimeout to ensure DOM updates are complete before selecting new session
        setTimeout(() => {
          // Get the first available session
          const firstSessionId = Array.from(sessions.keys())[0];
          // Ensure the session still exists before selecting it
          const newSession = sessions.get(firstSessionId);
          if (newSession && newSession.container) {
            // Clear selection first to ensure proper visual update
            selectedSessionId = null;
            // Then select the new session
            selectSession(firstSessionId);
          }
        }, 0);
      } else if (sessions.size === 0) {
        // No sessions left, clear selection
        selectedSessionId = null;
        clearConnectionLine();
      }
      
      updateSessionLayout();
    }

    // Update layout based on session count
    function updateSessionLayout() {
      const sessionCount = sessions.size;
      mainContent.setAttribute('data-session-count', sessionCount);
    }

    // Update connection status for a session
    function updateSessionConnectionStatus(session, status) {
      // Get the status indicator from the session header
      const statusIndicator = session.container.querySelector('.session-header .connection-status');
      
      if (statusIndicator) {
        statusIndicator.className = 'connection-status';
        
        switch(status) {
          case 'connected':
            statusIndicator.classList.add('connected');
            session.isConnected = true;
            break;
          case 'connecting':
            statusIndicator.classList.add('connecting');
            session.isConnected = false;
            break;
          case 'disconnected':
            session.isConnected = false;
            // When disconnected, reset the screenshot container and show placeholder
            resetScreenshotContainer(session);
            break;
        }
      }
    }

    // Reset screenshot container when connection is lost
    function resetScreenshotContainer(session) {
      // Hide image and show placeholder
      session.img.classList.add('hidden');
      session.placeholder.classList.remove('hidden');
      
      // Reset image source to prevent memory leaks
      if (session.img.src) {
        URL.revokeObjectURL(session.img.src);
        session.img.src = '';
      }
      
      // Reset image size container to ensure placeholder is centered
      const imageSizeContainer = session.content.querySelector('.image-size-container');
      if (imageSizeContainer) {
        imageSizeContainer.style.width = '';
        imageSizeContainer.style.height = '';
        imageSizeContainer.style.position = '';
        imageSizeContainer.style.top = '';
        imageSizeContainer.style.left = '';
        imageSizeContainer.style.transform = '';
      }
      
      // Reset screenshot container to ensure proper centering
      session.screenshotContainer.style.width = '';
      session.screenshotContainer.style.height = '';
    }

    // Setup WebSocket for a session
    function setupSessionWebSocket(session) {
      if (session.ws) session.ws.close();
      
      updateSessionConnectionStatus(session, 'connecting');
      
      session.ws = new WebSocket(`ws://${session.ip}:8080/ws`);

      session.ws.onopen = () => {
        console.log(`Connected to server ${session.ip}`);
        updateSessionConnectionStatus(session, 'connected');
        
        // Automatically start video when connection is established
        startSessionVideo(session, 'screenshot');
      };
      
      session.ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          console.log(`WebSocket message from ${session.ip}:`, data);
          
          if (data.type === 'tokenUpdate') {
            document.getElementById('tokenCounter').textContent = data.total;
          } else if (data.type === 'taskUpdate') {
            handleTaskUpdate(data);
          }
        } catch (error) {
          console.log(`WebSocket message from ${session.ip} (non-JSON):`, event.data);
        }
      };
      
      session.ws.onclose = () => {
        console.log(`Disconnected from server ${session.ip}`);
        updateSessionConnectionStatus(session, 'disconnected');
        // showToast(`Connection to server ${session.ip} was closed`, 'error');
      };
      
      session.ws.onerror = (error) => {
        console.error(`WebSocket error for ${session.ip}:`, error);
        updateSessionConnectionStatus(session, 'connecting');
        showToast(`Cannot establish connection to server ${session.ip}. Server is not responding.`, 'error');
      };
    }

    // Disconnect WebSocket for a session
    function disconnectSessionWebSocket(session) {
      if (session.ws) {
        session.ws.close();
        updateSessionConnectionStatus(session, 'disconnected');
      }
      
      // Stop video stream
      if (session.videoInterval) {
        clearInterval(session.videoInterval);
        session.videoInterval = null;
      }
      
      // Reset screenshot container to ensure proper centering
      resetScreenshotContainer(session);
    }

    // Start/stop video for a session
    function toggleSessionVideoLoop(session, endpoint) {
      if (session.videoInterval) {
        clearInterval(session.videoInterval);
        session.videoInterval = null;
        return false;
      } else {
        session.videoInterval = setInterval(() => {
          fetchSessionImage(session, endpoint);
        }, 1000 / currentFPS);
        return true;
      }
    }

    function startSessionVideo(session, endpoint) {
      if (!session.videoInterval) {
        session.videoInterval = setInterval(() => {
          fetchSessionImage(session, endpoint);
        }, 1000 / currentFPS);
      }
    }

    // Fetch image for a specific session
    async function fetchSessionImage(session, endpoint, shouldSample = false) {
      try {
        const response = await fetch(`http://${session.ip}:8080/${endpoint}`);
        if (!response.ok) throw new Error(`Failed to fetch ${endpoint} from ${session.ip}`);

        // Get the blob first
        const blob = await response.blob();
        
        // Track network data usage for this session
        const contentLength = response.headers.get('Content-Length');
        let bytes = 0;
        
        if (contentLength) {
          bytes = parseInt(contentLength);
          if (!isNaN(bytes)) {
            trackSessionNetworkData(session.id, bytes);
          }
        } else {
          // If Content-Length is not available, use blob size
          bytes = blob.size;
          trackSessionNetworkData(session.id, bytes);
        }

        const imageUrl = URL.createObjectURL(blob);
        if (session.img.src) URL.revokeObjectURL(session.img.src);
        session.img.src = imageUrl;
        
        session.img.onload = function() {
          const imageSizeContainer = session.content.querySelector('.image-size-container');
          
          // Check if we're in fullscreen mode
          const isFullscreen = document.fullscreenElement || 
                              document.webkitFullscreenElement || 
                              document.mozFullScreenElement || 
                              document.msFullscreenElement;
          
          if (!isFullscreen && imageSizeContainer) {
            // Set the container size to match the actual image dimensions for normal mode
            imageSizeContainer.style.width = this.width + 'px';
            imageSizeContainer.style.height = this.height + 'px';
            
            // Center the container in the session content
            imageSizeContainer.style.position = 'absolute';
            imageSizeContainer.style.top = '50%';
            imageSizeContainer.style.left = '50%';
            imageSizeContainer.style.transform = 'translate(-50%, -50%)';
          } else if (isFullscreen && imageSizeContainer) {
            // In fullscreen mode, let the CSS handle the positioning completely
            // Clear all inline styles to allow CSS fullscreen rules to take over
            imageSizeContainer.style.width = '';
            imageSizeContainer.style.height = '';
            imageSizeContainer.style.position = '';
            imageSizeContainer.style.top = '';
            imageSizeContainer.style.left = '';
            imageSizeContainer.style.transform = '';
          }
        };
        
        // Show image and hide placeholder
        session.img.classList.remove('hidden');
        session.placeholder.classList.add('hidden');
      } catch (error) {
        console.error(`Error fetching image from ${session.ip}:`, error);
        // Reset the screenshot container to ensure proper centering
        resetScreenshotContainer(session);
      }
    }

    // FPS Selection Function
    function setFPS(fps) {
      currentFPS = fps;
      
      // Update button states
      document.querySelectorAll('.fps-button').forEach(btn => {
        if (parseInt(btn.dataset.fps) === fps) {
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      });
      
      // Restart all active video streams with new FPS
      sessions.forEach(session => {
        if (session.videoInterval) {
          clearInterval(session.videoInterval);
          session.videoInterval = setInterval(() => {
            fetchSessionImage(session, 'screenshot');
          }, 1000 / currentFPS);
        }
      });
      
      console.log(`FPS set to: ${currentFPS}`);
    }

    // Mouse Functions for specific session
    async function sendSessionMouseClick(session) {
      try {
        const response = await fetch(`http://${session.ip}:8080/mouse-click`);
        if (!response.ok) throw new Error(`Failed to send mouse click to ${session.ip}`);
      } catch (error) {
        console.error(`Error sending mouse click to ${session.ip}:`, error);
      }
    }

    async function sendSessionMouseInput(session, x, y) {
      try {
        const response = await fetch(`http://${session.ip}:8080/mouse-input?x=${x}&y=${y}`);
        if (!response.ok) throw new Error(`Failed to send mouse input to ${session.ip}`);
      } catch (error) {
        console.error(`Error sending mouse input to ${session.ip}:`, error);
      }
    }

    function formatIp(ip) {
      if (ip.includes(':')) {
        return `[${ip}]`;
      } else {
        return `${ip}`;
      }
    }

    // Function to validate IP address format
    function isValidIP(ip) {
      // IPv4 validation: 4 octets, each 0-255
      const ipv4Regex = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;
      
      // IPv6 validation (simplified - allows various valid IPv6 formats)
      const ipv6Regex = /^([\da-fA-F]{1,4}:){7}[\da-fA-F]{1,4}$|^::([\da-fA-F]{1,4}:){0,6}[\da-fA-F]{1,4}$|^[\da-fA-F]{1,4}::([\da-fA-F]{1,4}:){0,5}[\da-fA-F]{1,4}$|^([\da-fA-F]{1,4}:){1}:([\da-fA-F]{1,4}:){0,5}[\da-fA-F]{1,4}$|^([\da-fA-F]{1,4}:){2}:([\da-fA-F]{1,4}:){0,4}[\da-fA-F]{1,4}$|^([\da-fA-F]{1,4}:){3}:([\da-fA-F]{1,4}:){0,3}[\da-fA-F]{1,4}$|^([\da-fA-F]{1,4}:){4}:([\da-fA-F]{1,4}:){0,2}[\da-fA-F]{1,4}$|^([\da-fA-F]{1,4}:){5}:([\da-fA-F]{1,4}:){0,1}[\da-fA-F]{1,4}$|^([\da-fA-F]{1,4}:){6}:[\da-fA-F]{1,4}$/;
      
      // Check for IPv4
      if (ipv4Regex.test(ip)) {
        const parts = ip.split('.');
        return parts.every(part => {
          const num = parseInt(part, 10);
          return num >= 0 && num <= 255 && part === num.toString();
        });
      }
      
      // Check for IPv6
      return ipv6Regex.test(ip);
    }

    // Global variable for validation error timeout
    let validationErrorTimeout = null;

    // Function to show validation error message
    function showValidationError(message) {
      // Remove any existing error message
      hideValidationError();
      
      // Clear any existing timeout
      if (validationErrorTimeout) {
        clearTimeout(validationErrorTimeout);
        validationErrorTimeout = null;
      }
      
      const inputGroup = document.querySelector('.input-group');
      const errorDiv = document.createElement('div');
      errorDiv.className = 'validation-error';
      errorDiv.textContent = message;
      errorDiv.style.cssText = 'display: flex; color: #ff6b6b; font-size: 11px; margin-top: 5px; padding: 4px 8px; background-color: rgba(255, 107, 107, 0.1); border-radius: 4px;';
      
      // Insert after the input group (below both input field and button)
      inputGroup.parentNode.insertBefore(errorDiv, inputGroup.nextSibling);
      
      // Auto-hide after 3 seconds, store timeout ID
      validationErrorTimeout = setTimeout(hideValidationError, 3000);
    }

    // Function to hide validation error message
    function hideValidationError() {
      const existingError = document.querySelector('.validation-error');
      if (existingError) {
        existingError.remove();
      }
      
      // Clear the timeout if it exists
      if (validationErrorTimeout) {
        clearTimeout(validationErrorTimeout);
        validationErrorTimeout = null;
      }
    }

    // Event Listeners
    document.getElementById("setTargetIP").addEventListener("click", () => {
      const ipInput = document.getElementById('ipv4');
      const ipValue = ipInput.value.trim();
      
      if (!isValidIP(ipValue)) {
        showValidationError('Please enter a valid IPv4 or IPv6 address');
        return;
      }

      // Hide validation error immediately if valid IP is entered
      hideValidationError();
      
      const ipAddress = formatIp(ipValue);
      
      // Create new session
      const session = createSession(ipAddress);
      
      // Setup WebSocket connection
      setupSessionWebSocket(session);
      
      // Clear IP input field and keep focus
      ipInput.value = '';
      ipInput.focus();
      
      // Button remains "Connect" for new connections
      const connectButton = document.getElementById('setTargetIP');
      connectButton.textContent = 'Connect';
    });

    // IP input field Enter key functionality
    document.getElementById("ipv4").addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        
        const ipInput = document.getElementById('ipv4');
        const ipValue = ipInput.value.trim();
        
        // Validate IP format
        if (!isValidIP(ipValue)) {
          showValidationError('Please enter a valid IPv4 or IPv6 address');
          return;
        }

        // Hide validation error immediately if valid IP is entered
        hideValidationError();
        
        const ipAddress = formatIp(ipValue);

        // Create new session
        const session = createSession(ipAddress);
        
        // Setup WebSocket connection
        setupSessionWebSocket(session);
        
        // Clear IP input field and keep focus
        ipInput.value = '';
        ipInput.focus();
        
        // Button remains "Connect" for new connections
        const connectButton = document.getElementById('setTargetIP');
        connectButton.textContent = 'Connect';
      }
    });

    // Toggle button event listener
    document.getElementById("toggleButtonsBtn").addEventListener("click", toggleDebugOptions);

    // Remove old event listeners that reference single-session functions
    // These will be replaced with session-specific controls
    document.getElementById("screenshotBtn").addEventListener("click", () => {
      const selectedSession = getSelectedSession();
      if (selectedSession) {
        fetchSessionImage(selectedSession, 'screenshot');
      } else {
        console.log("Please select a session first");
        alert("Please select a session first by clicking on it");
      }
    });
    
    document.getElementById("sendMouseClick").addEventListener("click", () => {
      const selectedSession = getSelectedSession();
      if (selectedSession) {
        sendSessionMouseClick(selectedSession);
      } else {
        console.log("Please select a session first");
        alert("Please select a session first by clicking on it");
      }
    });
    
    document.getElementById("sendMouseInput").addEventListener("click", () => {
      const x = parseInt(document.getElementById('x-coord').value) || 0;
      const y = parseInt(document.getElementById('y-coord').value) || 0;
      
      const selectedSession = getSelectedSession();
      if (selectedSession) {
        sendSessionMouseInput(selectedSession, x, y);
      } else {
        console.log("Please select a session first");
        alert("Please select a session first by clicking on it");
      }
    });

    // Video Controls - session-specific
    document.getElementById("videoBtn").addEventListener('click', function() {
      const selectedSession = getSelectedSession();
      if (selectedSession) {
        const isRunning = toggleSessionVideoLoop(selectedSession, 'screenshot');
        this.textContent = isRunning ? 'Stop Video' : 'Video';
      } else {
        console.log("Please select a session first");
        alert("Please select a session first by clicking on it");
      }
    });
    
    document.getElementById("video2").addEventListener('click', function() {
      const selectedSession = getSelectedSession();
      if (selectedSession) {
        const isRunning = toggleSessionVideoLoop(selectedSession, 'video2');
        this.textContent = isRunning ? 'Stop Video 2' : 'Video 2';
      } else {
        console.log("Please select a session first");
        alert("Please select a session first by clicking on it");
      }
    });

    // User-assist functionality
    let userAssistActive = false;
    let userAssistTaskCard = null;
    let userAssistConnectionPath = null;
    let userAssistPulseDots = [];

    // Function to calculate user-assist connection path (straight line from task card to chat)
    function calculateUserAssistPath(taskCardElement, chatElement) {
      const taskRect = taskCardElement.getBoundingClientRect();
      const chatRect = chatElement.getBoundingClientRect();
      const overlayRect = connectionSvg.getBoundingClientRect();
      
      // Calculate positions relative to SVG overlay
      const taskCenterX = taskRect.left + taskRect.width / 2 - overlayRect.left;
      const taskBottomY = taskRect.bottom - overlayRect.top;
      
      const chatCenterX = chatRect.left + chatRect.width / 2 - overlayRect.left;
      const chatTopY = chatRect.top - overlayRect.top;
      
      // Straight line from bottom center of task card to top center of chat
      return `M ${taskCenterX} ${taskBottomY} L ${chatCenterX} ${chatTopY}`;
    }

    // Function to draw user-assist connection line
    function drawUserAssistConnectionLine(taskCardElement, chatElement) {
      // Clear any existing user-assist connection
      clearUserAssistConnectionLine();
      
      const pathData = calculateUserAssistPath(taskCardElement, chatElement);
      
      // Create SVG path
      userAssistConnectionPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      userAssistConnectionPath.setAttribute('d', pathData);
      userAssistConnectionPath.setAttribute('class', 'connection-path user-assist');
      userAssistConnectionPath.setAttribute('stroke', '#FFC107');
      
      connectionSvg.appendChild(userAssistConnectionPath);
      
      // Create traveling pulse dots
      createUserAssistPulseDots(pathData);
      
      console.log('User-assist connection line drawn');
    }

    // Function to create user-assist traveling pulse dots
    function createUserAssistPulseDots(pathData) {
      // Create multiple pulse dots with staggered delays
      for (let i = 0; i < 3; i++) {
        const pulseDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        pulseDot.setAttribute('class', 'pulse-dot user-assist');
        pulseDot.setAttribute('r', '3');
        pulseDot.setAttribute('fill', '#FFC107');
        pulseDot.style.animationDelay = `${i * 0.3}s`;
        
        // Position the dot at the start of the path initially
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', pathData);
        const totalLength = path.getTotalLength();
        const point = path.getPointAtLength(0);
        
        pulseDot.setAttribute('cx', point.x);
        pulseDot.setAttribute('cy', point.y);
        
        connectionSvg.appendChild(pulseDot);
        userAssistPulseDots.push(pulseDot);
      }
    }

    // Function to clear user-assist connection line
    function clearUserAssistConnectionLine() {
      if (userAssistConnectionPath) {
        connectionSvg.removeChild(userAssistConnectionPath);
        userAssistConnectionPath = null;
      }
      
      // Clear pulse dots
      userAssistPulseDots.forEach(dot => {
        if (dot.parentNode === connectionSvg) {
          connectionSvg.removeChild(dot);
        }
      });
      userAssistPulseDots = [];
    }

    // Function to add user-assist badge to chat legend
    function addUserAssistBadge() {
      const chatLegend = document.querySelector('#chatFieldset legend');
      if (chatLegend && !chatLegend.querySelector('.user-assist-badge')) {
        const badge = document.createElement('span');
        badge.className = 'user-assist-badge';
        badge.textContent = 'user-assist';
        chatLegend.appendChild(badge);
      }
    }

    // Function to remove user-assist badge from chat legend
    function removeUserAssistBadge() {
      const chatLegend = document.querySelector('#chatFieldset legend');
      if (chatLegend) {
        const badge = chatLegend.querySelector('.user-assist-badge');
        if (badge) {
          chatLegend.removeChild(badge);
        }
      }
    }

    // Function to activate user-assist mode
    function activateUserAssist(taskCard) {
      // Only allow activation for in-progress tasks
      if (!taskCard.classList.contains('in-progress')) {
        console.log('User-assist cannot be activated for non-in-progress tasks');
        return;
      }
      
      if (userAssistActive && userAssistTaskCard === taskCard) {
        // If already active for this task card, deactivate it
        deactivateUserAssist();
        return;
      }
      
      // Deactivate any existing user-assist
      deactivateUserAssist();
      
      userAssistActive = true;
      userAssistTaskCard = taskCard;
      
      // Get the session ID from the task card and switch session focus
      const sessionId = taskCard.dataset.sessionId;
      if (sessionId && sessionId !== 'null' && sessionId !== 'undefined') {
        selectSession(sessionId);
      }
      
      // Draw connection line
      const chatFieldset = document.getElementById('chatFieldset');
      drawUserAssistConnectionLine(taskCard, chatFieldset);
      
      // Add badge to chat legend
      addUserAssistBadge();
      
      // Change chat input color
      const chatInput = document.getElementById('llmChatInput');
      const chatFieldsetElement = document.getElementById('chatFieldset');
      chatInput.classList.add('user-assist-active');
      chatFieldsetElement.classList.add('user-assist-active');
      
      console.log('User-assist activated');
    }

    // Function to deactivate user-assist mode
    function deactivateUserAssist() {
      if (!userAssistActive) return;
      
      // Clear both connection lines (chat-to-session and chat-to-task)
      clearUserAssistConnectionLine();
      clearConnectionLine();
      
      // Remove badge from chat legend
      removeUserAssistBadge();
      
      // Restore chat input color
      const chatInput = document.getElementById('llmChatInput');
      const chatFieldsetElement = document.getElementById('chatFieldset');
      chatInput.classList.remove('user-assist-active');
      chatFieldsetElement.classList.remove('user-assist-active');
      
      // Update session selection to remove user-assist styling
      // Don't add 'selected' class back - let the new session selection handle this
      if (selectedSessionId) {
        const session = sessions.get(selectedSessionId);
        if (session && session.container) {
          session.container.classList.remove('user-assist-selected');
          // Don't add 'selected' class here - let the new session selection handle it
        }
      }
      
      // Force a complete redraw of the normal connection line to ensure no golden styling remains
      if (selectedSessionId) {
        // Clear first to ensure clean state
        clearConnectionLine();
        
        // Then redraw with normal styling by temporarily setting userAssistActive to false
        const session = sessions.get(selectedSessionId);
        const chatFieldset = document.getElementById('chatFieldset');
        
        if (session && chatFieldset) {
          // Temporarily set userAssistActive to false to ensure normal styling
          const wasUserAssistActive = userAssistActive;
          userAssistActive = false;
          drawConnectionLine(chatFieldset, session.container);
          userAssistActive = wasUserAssistActive;
        }
      }
      
      userAssistActive = false;
      userAssistTaskCard = null;
      
      console.log('User-assist deactivated');
    }

    // Global task counter for sequence numbers
    let taskSequenceNumber = 1;

    // Function for smart scrolling based on task position
    function smartScrollToTask(taskCard) {
      const tasksContainer = document.getElementById('tasksContainer');
      const taskCards = Array.from(tasksContainer.querySelectorAll('.task-card'));
      const taskIndex = taskCards.indexOf(taskCard);
      const totalTasks = taskCards.length;
      
      if (taskIndex === 0) {
        // First task - scroll to top
        tasksContainer.scrollTo({ top: 0, behavior: 'smooth' });
      } else if (taskIndex === totalTasks - 1) {
        // Last task - scroll to bottom
        tasksContainer.scrollTo({ top: tasksContainer.scrollHeight, behavior: 'smooth' });
      } else {
        // Middle task - scroll to center
        const taskRect = taskCard.getBoundingClientRect();
        const containerRect = tasksContainer.getBoundingClientRect();
        const containerCenter = containerRect.height / 2;
        const taskCenter = taskRect.top - containerRect.top + taskRect.height / 2;
        const scrollOffset = taskCenter - containerCenter;
        
        tasksContainer.scrollBy({ top: scrollOffset, behavior: 'smooth' });
      }
    }

    // Update task card click handler to include user-assist functionality
    function createTaskCard(message, status = 'in-progress', sessionId = null) {
      const taskCard = document.createElement('div');
      taskCard.className = `task-card ${status}`;
      
      // Store original message as data attribute for later reference
      taskCard.dataset.originalMessage = message;
      taskCard.dataset.sequenceNumber = taskSequenceNumber;
      if (sessionId) {
        taskCard.dataset.sessionId = sessionId;
      }
      
      // Add click event to handle user-assist activation and smart scrolling
      taskCard.addEventListener('click', (event) => {
        // Check if the click was on an actionable element (buttons, icons)
        const actionableElements = [
          '.task-session-window-icon',
          '.task-cancel-btn',
          '.task-info-icon'
        ];
        
        const clickedElement = event.target;
        const isActionable = actionableElements.some(selector => 
          clickedElement.closest(selector)
        );
        
        // Only handle user-assist if not clicking on actionable elements
        if (!isActionable) {
          // Smart scroll based on task position
          smartScrollToTask(taskCard);
          
          // Toggle user-assist only for in-progress tasks
          if (taskCard.classList.contains('in-progress')) {
            activateUserAssist(taskCard);
          } else if (userAssistActive) {
            // If user-assist is already active and clicking on a non-in-progress task, deactivate it
            deactivateUserAssist();
          }
        }
      });
      
      // Increment sequence number for next task
      taskSequenceNumber++;
      
      const taskHeader = document.createElement('div');
      taskHeader.className = 'task-header';
      
      // Create left side container for sequence number and status
      const taskHeaderLeft = document.createElement('div');
      taskHeaderLeft.className = 'task-header-left';
      
      // Add sequence number
      const sequenceNumber = document.createElement('span');
      sequenceNumber.className = 'task-sequence-number';
      sequenceNumber.textContent = `#${taskCard.dataset.sequenceNumber}`;
      sequenceNumber.style.fontSize = '10px';
      sequenceNumber.style.color = '#888';
      sequenceNumber.style.marginRight = '8px';
      
      const taskStatus = document.createElement('span');
      taskStatus.className = 'task-status';
      taskStatus.textContent = status === 'in-progress' ? 'In Progress' : 
                             status === 'completed' ? 'Completed' :
                             status === 'broken' ? 'Broken' : 'Canceled';
      
      taskHeaderLeft.appendChild(sequenceNumber);
      taskHeaderLeft.appendChild(taskStatus);
      
      taskHeader.appendChild(taskHeaderLeft);
      
      const controlsContainer = document.createElement('div');
      controlsContainer.className = 'task-header-controls';
      
      // Add session window icon for all tasks with session ID
      if (sessionId) {
        const fullscreenIcon = document.createElement('div');
        fullscreenIcon.className = 'task-session-window-icon';
        fullscreenIcon.innerHTML = '⛶'; // Fullscreen-like icon
        fullscreenIcon.title = 'Open session window';
        fullscreenIcon.addEventListener('click', (event) => {
          event.stopPropagation(); // Prevent triggering task selection
          openTaskSessionWindow(sessionId);
        });
        controlsContainer.appendChild(fullscreenIcon);
      }
      
      // Add cancel button for in-progress tasks
      if (status === 'in-progress') {
        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'task-cancel-btn';
        cancelBtn.textContent = 'Cancel';
        cancelBtn.addEventListener('click', () => {
          cancelTask(taskCard);
        });
        controlsContainer.appendChild(cancelBtn);
      }
      
      // Add info icon for non-in-progress tasks
      if (status !== 'in-progress') {
        const infoIcon = document.createElement('div');
        infoIcon.className = 'task-info-icon';
        infoIcon.textContent = '?';
        let infoTitle = message;
        if (sessionId) {
          infoTitle += `\nSession: ${sessionId}`;
        }
        infoIcon.title = infoTitle;
        controlsContainer.appendChild(infoIcon);
      }
      
      taskHeader.appendChild(controlsContainer);
      taskCard.appendChild(taskHeader);
      
      // Add session info if available
      const sessionInfo = document.createElement('div');
      sessionInfo.className = 'task-session-info';
      sessionInfo.style.fontSize = '10px';
      sessionInfo.style.color = '#888';
      sessionInfo.style.marginBottom = '4px';
      
      if (sessionId) {
        sessionInfo.textContent = `Session: ${sessionId}`;
      } else {
        sessionInfo.textContent = 'Session: Unknown';
      }
      
      const taskMessage = document.createElement('div');
      taskMessage.className = 'task-message';
      taskMessage.textContent = message.length > 100 ? message.substring(0, 100) + '...' : message;
      
      taskCard.appendChild(sessionInfo);
      taskCard.appendChild(taskMessage);
      
      // Add timer for in-progress tasks
      if (status === 'in-progress') {
        const timerContainer = document.createElement('div');
        timerContainer.className = 'task-timer';
        
        const timerText = document.createElement('span');
        timerText.className = 'timer-text';
        timerText.textContent = '00:00:00:00:000';
        
        timerContainer.appendChild(timerText);
        taskCard.appendChild(timerContainer);
        
        // Store creation time for timer
        taskCard.dataset.createdAt = Date.now();
        
        // Start timer
        startTaskTimer(taskCard);
      }
      
      return taskCard;
    }
    
    function startTaskTimer(taskCard) {
      const timerElement = taskCard.querySelector('.timer-text');
      if (!timerElement) return;
      
      const createdAt = parseInt(taskCard.dataset.createdAt);
      const timerInterval = setInterval(() => {
        const elapsed = Date.now() - createdAt;
        timerElement.textContent = formatElapsedTime(elapsed);
      }, 10); // Update every 10ms for milliseconds precision
      
      // Store interval ID for cleanup
      taskCard.dataset.timerInterval = timerInterval;
    }
    
    function stopTaskTimer(taskCard) {
      const intervalId = taskCard.dataset.timerInterval;
      if (intervalId) {
        clearInterval(intervalId);
        delete taskCard.dataset.timerInterval;
      }
    }
    
    function formatElapsedTime(milliseconds) {
      const days = Math.floor(milliseconds / (1000 * 60 * 60 * 24));
      const hours = Math.floor((milliseconds % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
      const minutes = Math.floor((milliseconds % (1000 * 60 * 60)) / (1000 * 60));
      const seconds = Math.floor((milliseconds % (1000 * 60)) / 1000);
      const ms = milliseconds % 1000;
      
      return `${days.toString().padStart(2, '0')}:${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}:${ms.toString().padStart(3, '0')}`;
    }
    
    function showTasksSection() {
      const tasksSection = document.getElementById('tasksSection');
      const chatFieldset = document.getElementById('chatFieldset');
      
      // Show tasks section with flexible sizing
      tasksSection.classList.add('visible');
      
      // Calculate dynamic flex value based on tasks content
      const tasksContainer = document.getElementById('tasksContainer');
      const taskCount = tasksContainer.children.length;
      const dynamicFlex = Math.max(1.5, 3 - (taskCount * 0.3)); // Adjust flex based on task count
      
      // Apply dynamic flex to chat section
      chatFieldset.style.flex = `${dynamicFlex}`;
    }
    
    function cancelTask(taskCard) {
      const taskId = taskCard.dataset.taskId;
      const sessionId = taskCard.dataset.sessionId;
      if (!taskId) return;

      // Find the session to send the cancellation request to
      let targetSession = null;
      if (sessionId) {
        targetSession = sessions.get(sessionId);
      }
      
      if (!targetSession && sessions.size > 0) {
        // If no specific session is associated, use the first available session
        const firstSessionId = Array.from(sessions.keys())[0];
        targetSession = sessions.get(firstSessionId);
      }

      if (!targetSession) {
        console.error('No active session available to cancel task');
        return;
      }

      // Send cancellation request to the appropriate session
      fetch(`http://${targetSession.ip}:8080/task-cancel?taskId=${taskId}`)
        .then(response => response.json())
        .then(data => {
          console.log('Task cancellation response:', data);
          
          // Update UI based on backend response
          if (data.result === 'Task canceled successfully') {
            taskCard.classList.remove('in-progress');
            taskCard.classList.add('canceled');
            
            const statusElement = taskCard.querySelector('.task-status');
            statusElement.textContent = 'Canceled';
            
            // Remove cancel button
            const cancelBtn = taskCard.querySelector('.task-cancel-btn');
            if (cancelBtn) {
              cancelBtn.remove();
            }
            
            // Update current task status
            if (currentTask === taskCard) {
              currentTask = null;
            }
          }
        })
        .catch(error => {
          console.error('Error canceling task:', error);
        });
    }
    
    function handleTaskUpdate(data) {
      console.log('Task update received:', data);
      
      // Debug: Check if we have the expected data structure
      if (!data.taskId || !data.status) {
        console.error('Invalid task update data:', data);
        return;
      }
      
      const tasksContainer = document.getElementById('tasksContainer');
      const taskCards = tasksContainer.querySelectorAll('.task-card');
      
      // First, check if we have a pending task that needs to be updated with real task ID
      let taskCard = null;
      for (const card of taskCards) {
        if (card.dataset.taskId === 'pending') {
          // Found a pending task - update it with the real task ID
          card.dataset.taskId = data.taskId;
          
          // Enable cancel button now that we have a real task ID
          const cancelBtn = card.querySelector('.task-cancel-btn');
          if (cancelBtn) {
            cancelBtn.disabled = false;
            cancelBtn.textContent = 'Cancel';
          }
          
          taskCard = card;
          break;
        } else if (card.dataset.taskId === data.taskId) {
          taskCard = card;
          break;
        }
      }
      
      if (!taskCard) {
        // Create new task card if it doesn't exist
        taskCard = createTaskCard(data.message, data.status);
        taskCard.dataset.taskId = data.taskId;
        tasksContainer.appendChild(taskCard);
        
        // Show tasks section if it's the first task
        if (tasksContainer.children.length === 1) {
          showTasksSection();
        }
      } else {
        // Update existing task card
        console.log('Updating task card with status:', data.status);
        
        // Remove all status classes first
        taskCard.classList.remove('in-progress', 'completed', 'broken', 'canceled');
        // Add the new status class based on the status field
        taskCard.classList.add(data.status);
        
        const statusElement = taskCard.querySelector('.task-status');
        const messageElement = taskCard.querySelector('.task-message');
        
        if (statusElement) {
          statusElement.textContent = data.status === 'in-progress' ? 'In Progress' : 
                                    data.status === 'completed' ? 'Completed' :
                                    data.status === 'broken' ? 'Broken' : 'Canceled';
        }
        
        if (messageElement && data.message) {
          messageElement.textContent = data.message.length > 100 ? 
                                     data.message.substring(0, 100) + '...' : data.message;
        }
        
        // Remove cancel button if task is completed, broken, or canceled
        if (data.status !== 'in-progress') {
          const cancelBtn = taskCard.querySelector('.task-cancel-btn');
          if (cancelBtn) {
            cancelBtn.remove();
          }
        }
        
        // Add or remove info icon based on new status
        const controlsContainer = taskCard.querySelector('.task-header-controls');
        const existingInfoIcon = taskCard.querySelector('.task-info-icon');
        
        if (data.status !== 'in-progress') {
          // Add info icon if it doesn't exist
          if (!existingInfoIcon && controlsContainer) {
            const infoIcon = document.createElement('div');
            infoIcon.className = 'task-info-icon';
            infoIcon.textContent = '?';
            infoIcon.title = taskCard.dataset.originalMessage;
            
            controlsContainer.appendChild(infoIcon);
          } else if (existingInfoIcon) {
            // Update title if info icon already exists
            existingInfoIcon.title = taskCard.dataset.originalMessage;
          }
        } else {
          // Remove info icon if status is 'in-progress'
          if (existingInfoIcon) {
            existingInfoIcon.remove();
          }
        }
        
        // Stop timer if task is no longer in progress
        if (data.status !== 'in-progress') {
          stopTaskTimer(taskCard);
          
          // Deactivate user-assist if this was the active task
          if (userAssistActive && userAssistTaskCard === taskCard) {
            deactivateUserAssist();
          }
        }
      }
      
      // Update current task reference
      if (data.status === 'in-progress') {
        currentTask = taskCard;
      } else if (currentTask === taskCard) {
        currentTask = null;
      }
      
      // Scroll to bottom to show the updated/created task
      setTimeout(scrollTasksToBottom, 0);
    }

    function scrollTasksToBottom() {
      const tasksContainer = document.getElementById('tasksContainer');
      if (tasksContainer) {
        tasksContainer.scrollTop = tasksContainer.scrollHeight;
      }
    }

    // Function to check server availability
    async function checkServerAvailability(ip) {
      try {
        const response = await fetch(`http://${ip}:8080/ping`, {
          method: 'GET',
          signal: AbortSignal.timeout(3000) // 3 second timeout
        });
        return response.ok;
      } catch (error) {
        console.error(`Server ${ip} is not available:`, error);
        return false;
      }
    }

    // Function to open session window for a task
    async function openTaskSessionWindow(sessionId) {
      console.log(`Opening session window for: ${sessionId}`);
      
      // First check if server is available
      const isServerAvailable = await checkServerAvailability(sessionId);
      
      if (!isServerAvailable) {
        showToast(`Cannot establish connection to server ${sessionId}. Server is not responding.`, 'error');
        return;
      }
      
      // Check if session already exists
      let session = sessions.get(sessionId);
      
      if (!session) {
        // Session doesn't exist, create a new one
        session = createSession(sessionId);
        setupSessionWebSocket(session);
        console.log(`Created new session for: ${sessionId}`);
      } else {
        // Session exists, select it and ensure it's connected
        selectSession(sessionId);
        if (!session.isConnected) {
          setupSessionWebSocket(session);
          console.log(`Reconnected to existing session: ${sessionId}`);
        } else {
          console.log(`Session already connected: ${sessionId}`);
        }
      }
      
      // Ensure the session is visible and focused
      if (session.container) {
        session.container.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }
    }

    function handleTaskCreation(message, sessionId = null) {
      // Create task card for every message with temporary ID
      const tasksContainer = document.getElementById('tasksContainer');
      
      const taskCard = createTaskCard(message, 'in-progress', sessionId);
      taskCard.dataset.taskId = 'pending'; // Temporary ID until we get real one
      tasksContainer.appendChild(taskCard);
      currentTask = taskCard;
      
      // Disable cancel button until we get real task ID
      const cancelBtn = taskCard.querySelector('.task-cancel-btn');
      if (cancelBtn) {
        cancelBtn.disabled = true;
        cancelBtn.textContent = 'Cancel';
      }
      
      // Show tasks section if it's the first task
      if (tasksContainer.children.length === 1) {
        showTasksSection();
      }
      
      // Scroll to bottom to show the new task
      setTimeout(scrollTasksToBottom, 0);
      
      isFirstMessage = false;
    }

    // LLM Chat
    document.getElementById("llmSendButton").addEventListener("click", () => {
      const inputText = document.getElementById('llmChatInput').value;
      if (!inputText) return;

      // Get the currently selected session or use the first available session
      let targetSession = getSelectedSession();
      if (!targetSession && sessions.size > 0) {
        // If no session is selected, use the first session
        const firstSessionId = Array.from(sessions.keys())[0];
        targetSession = sessions.get(firstSessionId);
      }

      if (!targetSession) {
        console.error('No active session available to send task to');
        alert('Please connect to a session first');
        return;
      }

      // Send the task to the selected session
      fetch(`http://${targetSession.ip}:8080/llm-input`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text: inputText })
      }).catch(error => {
        console.error('Error sending task to session:', error);
      });

      // Handle task creation with session ID
      handleTaskCreation(inputText, targetSession.id);
      
      document.getElementById('llmChatInput').value = "";
    });

    // Hotkey functionality for chat input
    document.getElementById("llmChatInput").addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        if (event.shiftKey) {
          // Shift+Enter - allow default behavior (new line)
          return;
        } else {
          // Enter without Shift - send message if input is not empty
          event.preventDefault();
          const inputText = document.getElementById('llmChatInput').value.trim();
          if (inputText) {
            document.getElementById("llmSendButton").click();
          }
        }
      }
    });

    // Pop Out WS
    document.getElementById("popOutWSButton").addEventListener("click", function() {
      // Open window with specific features for better visibility
      popOutWSWindow = window.open('', '_blank', 'width=800,height=600,resizable=yes,scrollbars=yes');

      if (popOutWSWindow) {
        const html = `<!DOCTYPE html>
<html>
<head>
  <title>WebSocket Output</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      background-color: #1e1e1e;
      color: #fff;
      font-family: monospace;
    }
    #poppedTextarea {
      width: 100%;
      height: calc(100vh - 40px);
      background-color: #000;
      color: #fff;
      border: 1px solid #333;
      padding: 10px;
      font-size: 14px;
      line-height: 1.4;
      resize: none;
      box-sizing: border-box;
    }
  </style>
</head>
<body>
  <textarea id="poppedTextarea" readonly></textarea>
  <script>
    // Debug logging
    console.log('Pop-out window loaded');
    
    const ip = '${ip}';
    let ws = null;
    const textarea = document.getElementById('poppedTextarea');
    
    function log(msg) {
      console.log(msg);
      textarea.value += msg + '\\n';
      textarea.scrollTop = textarea.scrollHeight;
    }

    function setupWebSocket() {
      try {
        log('Attempting WebSocket connection...');
        
        ws = new WebSocket('ws://' + ip + ':8080/ws');
        
        ws.onopen = () => {
          log('Connected to WebSocket server');
        };
        
        ws.onmessage = (event) => {
          if (!event.data) return;
          
          try {
            const parsed = JSON.parse(event.data);
            const formatted = JSON.stringify(parsed, null, 2);
            log('Received: ' + formatted);
          } catch (e) {
            log('Received: ' + event.data);
          }
        };

        ws.onclose = () => {
          log('WebSocket connection closed');
          ws = null;
          // Try to reconnect after 3 seconds
          setTimeout(setupWebSocket, 3000);
        };

        ws.onerror = (error) => {
          log('WebSocket error: ' + error.message);
        };

      } catch (error) {
        log('Setup error: ' + error.message);
      }
    }

    // Start connection when window loads
    window.addEventListener('load', setupWebSocket);
  <\/script>
</body>
</html>`;

        // Write the HTML and explicitly close the document
        popOutWSWindow.document.open();
        popOutWSWindow.document.write(html);
        popOutWSWindow.document.close();

        // Log success in main window
        console.log('Pop-out window created successfully');
      } else {
        console.error('Failed to create pop-out window');
      }
    });
    
    // FPS Button Event Listeners
    document.querySelectorAll('.fps-button').forEach(button => {
      button.addEventListener('click', function() {
        const fps = parseInt(this.dataset.fps);
        setFPS(fps);
      });
    });

    // Initialize default FPS state
    setFPS(currentFPS);
    
    // Session-specific fullscreen functionality
    function setupSessionFullscreen(session) {
      const screenshotOverlay = session.content.querySelector('.screenshot-overlay');
      const screenshotContainer = session.screenshotContainer;
      const fullscreenBtn = session.fullscreenBtn;
      const maximizeBtn = screenshotOverlay.querySelector('.fullscreen-button:first-child');
      const llmChatInput = document.getElementById('llmChatInput');
      
      // Inactivity timer for overlay
      let overlayTimeout = null;
      const OVERLAY_TIMEOUT = 3000; // 3 seconds
      
      function resetOverlayTimer() {
        // Clear existing timeout
        if (overlayTimeout) {
          clearTimeout(overlayTimeout);
        }
        
        // Only set timeout if in fullscreen mode
        const isFullscreen = document.fullscreenElement || 
                            document.webkitFullscreenElement || 
                            document.mozFullScreenElement || 
                            document.msFullscreenElement;
        
        if (isFullscreen) {
          // Show overlay immediately when activity is detected
          screenshotOverlay.style.opacity = '1';
          screenshotOverlay.style.pointerEvents = 'auto';
          
          // Set new timeout to hide overlay after inactivity
          overlayTimeout = setTimeout(() => {
            screenshotOverlay.style.opacity = '0';
            screenshotOverlay.style.pointerEvents = 'none';
          }, OVERLAY_TIMEOUT);
        }
      }
      
      // Mouse event handling for overlay
      let isMouseOverOverlay = false;
      let isMouseOverContainer = false;
      
      // Handle mouse enter on overlay
      screenshotOverlay.addEventListener('mouseenter', () => {
        isMouseOverOverlay = true;
        if (overlayTimeout) {
          clearTimeout(overlayTimeout);
        }
      });
      
      // Handle mouse leave from overlay
      screenshotOverlay.addEventListener('mouseleave', () => {
        isMouseOverOverlay = false;
        // Only hide if mouse is not over container either
        if (!isMouseOverContainer) {
          const isFullscreen = document.fullscreenElement || 
                              document.webkitFullscreenElement || 
                              document.mozFullScreenElement || 
                              document.msFullscreenElement;
          
          if (!isFullscreen) {
            // Normal mode - hide overlay immediately when mouse leaves
            screenshotOverlay.style.opacity = '0';
            screenshotOverlay.style.pointerEvents = 'none';
          } else {
            // Fullscreen mode - start timer
            resetOverlayTimer();
          }
        }
      });
      
      // Handle mouse enter on container
      screenshotContainer.addEventListener('mouseenter', () => {
        isMouseOverContainer = true;
        const isFullscreen = document.fullscreenElement || 
                            document.webkitFullscreenElement || 
                            document.mozFullScreenElement || 
                            document.msFullscreenElement;
        
        if (isFullscreen) {
          // Fullscreen mode - show overlay and start timer
          screenshotOverlay.style.opacity = '1';
          screenshotOverlay.style.pointerEvents = 'auto';
          resetOverlayTimer();
        } else {
          // Normal mode - show overlay immediately
          screenshotOverlay.style.opacity = '1';
          screenshotOverlay.style.pointerEvents = 'auto';
        }
      });
      
      // Handle mouse leave from container
      screenshotContainer.addEventListener('mouseleave', () => {
        isMouseOverContainer = false;
        // Only hide if mouse is not over overlay either
        if (!isMouseOverOverlay) {
          const isFullscreen = document.fullscreenElement || 
                              document.webkitFullscreenElement || 
                              document.mozFullScreenElement || 
                              document.msFullscreenElement;
          
          if (!isFullscreen) {
            // Normal mode - hide overlay immediately when mouse leaves container
            screenshotOverlay.style.opacity = '0';
            screenshotOverlay.style.pointerEvents = 'none';
          } else {
            // Fullscreen mode - start timer
            resetOverlayTimer();
          }
        }
      });
      
      // Mouse move detection for both container and overlay
      screenshotContainer.addEventListener('mousemove', resetOverlayTimer);
      screenshotOverlay.addEventListener('mousemove', resetOverlayTimer);
      
      // Reset timer on key press
      document.addEventListener('keydown', resetOverlayTimer);
      
      // Reset timer on fullscreen button click
      fullscreenBtn.addEventListener('click', resetOverlayTimer);
      
      // Fullscreen button click handler
      fullscreenBtn.addEventListener('click', () => {
        toggleSessionFullscreen(session);
      });
      
      // Maximize button click handler
      maximizeBtn.addEventListener('click', () => {
        toggleSessionMaximize(session);
      });
      
      // Make screenshot container focusable and handle focus for keyboard navigation
      screenshotContainer.setAttribute('tabindex', '0');
      screenshotContainer.addEventListener('focus', () => {
        screenshotContainer.classList.add('focused');
      });
      
      screenshotContainer.addEventListener('blur', () => {
        screenshotContainer.classList.remove('focused');
      });
      
      // Also allow fullscreen when container is focused and Enter key is pressed
      screenshotContainer.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' || event.key === ' ') {
          event.preventDefault();
          toggleSessionFullscreen(session);
        }
      });
      
      // Focus screenshot container when clicked with left mouse button
      screenshotContainer.addEventListener('mousedown', (event) => {
        // Only handle left mouse button clicks (button 0)
        if (event.button === 0) {
          event.preventDefault();
          screenshotContainer.focus();
        }
      });
      
      // Also focus when the image itself is clicked (in case click doesn't bubble properly)
      session.img.addEventListener('mousedown', (event) => {
        if (event.button === 0) {
          event.preventDefault();
          screenshotContainer.focus();
        }
      });
    }
    
    function toggleSessionFullscreen(session) {
      const screenshotContainer = session.screenshotContainer;
      
      if (!document.fullscreenElement) {
        // Enter fullscreen
        if (screenshotContainer.requestFullscreen) {
          screenshotContainer.requestFullscreen().catch(err => {
            console.error('Error attempting to enable fullscreen:', err);
          });
        } else if (screenshotContainer.webkitRequestFullscreen) { /* Safari */
          screenshotContainer.webkitRequestFullscreen();
        } else if (screenshotContainer.msRequestFullscreen) { /* IE11 */
          screenshotContainer.msRequestFullscreen();
        }
      } else {
        // Exit fullscreen
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.webkitExitFullscreen) { /* Safari */
          document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) { /* IE11 */
          document.msExitFullscreen();
        }
      }
    }

    // Toggle session maximize functionality
    function toggleSessionMaximize(session) {
      const sessionContainer = session.container;
      const mainContent = document.getElementById('mainContent');
      
      // Check if session is already maximized
      const isMaximized = sessionContainer.classList.contains('maximized');
      
      if (isMaximized) {
        // Restore normal layout - show all sessions
        sessionContainer.classList.remove('maximized');
        sessions.forEach((otherSession, sessionId) => {
          otherSession.container.style.display = 'flex';
        });
        mainContent.setAttribute('data-session-count', sessions.size);
      } else {
        // Maximize the session - hide all other sessions
        sessionContainer.classList.add('maximized');
        sessions.forEach((otherSession, sessionId) => {
          if (sessionId !== session.id) {
            otherSession.container.style.display = 'none';
          }
        });
        mainContent.setAttribute('data-session-count', '1');
      }
    }
    
    // Global keyboard shortcut for fullscreen (F key) and maximize (M key) - applies to selected session
    document.addEventListener('keydown', (event) => {
      // Check if chat input or IP input is focused
      const isChatInputFocused = document.activeElement === document.getElementById('llmChatInput');
      const isIpInputFocused = document.activeElement === document.getElementById('ipv4');
      
      if (!isChatInputFocused && !isIpInputFocused) {
        // Fullscreen shortcut (F key)
        if (event.key === 'f' || event.key === 'F') {
          event.preventDefault(); // Prevent default browser behavior
          
          // Check if we're already in fullscreen mode
          const isFullscreen = document.fullscreenElement || 
                              document.webkitFullscreenElement || 
                              document.mozFullScreenElement || 
                              document.msFullscreenElement;
          
          if (isFullscreen) {
            // Exit fullscreen mode
            if (document.exitFullscreen) {
              document.exitFullscreen();
            } else if (document.webkitExitFullscreen) { /* Safari */
              document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) { /* IE11 */
              document.msExitFullscreen();
            }
          } else {
            // Enter fullscreen mode for selected session
            const selectedSession = getSelectedSession();
            if (selectedSession) {
              toggleSessionFullscreen(selectedSession);
            }
          }
        }
        
        // Maximize shortcut (M key)
        if (event.key === 'm' || event.key === 'M') {
          event.preventDefault(); // Prevent default browser behavior
          
          // Maximize the selected session
          const selectedSession = getSelectedSession();
            if (selectedSession) {
              toggleSessionMaximize(selectedSession);
            }
        }
      }
    });
    
    // Listen for fullscreen change events to handle container size properly
    document.addEventListener('fullscreenchange', handleFullscreenChange);
    document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
    document.addEventListener('msfullscreenchange', handleFullscreenChange);
    
    function handleFullscreenChange() {
      // Update all sessions when fullscreen changes
      const isFullscreen = document.fullscreenElement || 
                          document.webkitFullscreenElement || 
                          document.mozFullScreenElement || 
                          document.msFullscreenElement;
      
      sessions.forEach(session => {
        const imageSizeContainer = session.content.querySelector('.image-size-container');
        const screenshotOverlay = session.content.querySelector('.screenshot-overlay');
        
        if (isFullscreen) {
          // Remove inline styles when entering fullscreen to allow CSS to take over
          if (imageSizeContainer) {
            imageSizeContainer.style.width = '';
            imageSizeContainer.style.height = '';
          }
        } else {
          // Restore inline styles when exiting fullscreen
          if (imageSizeContainer && session.img.width && session.img.height) {
            imageSizeContainer.style.width = session.img.width + 'px';
            imageSizeContainer.style.height = session.img.height + 'px';
          }
          
          // Hide overlay toolbars for all sessions when exiting fullscreen
          if (screenshotOverlay) {
            screenshotOverlay.style.opacity = '0';
            screenshotOverlay.style.pointerEvents = 'none';
          }
        }
      });
    }
    
    // Test function to verify task creation works
    function testTaskCreation() {
      console.log('Testing task creation...');
      handleTaskCreation('Test task message for demonstration purposes');
    }
    
    // Uncomment the line below to test the task creation functionality
    // testTaskCreation();

    // Connection line functionality
    const connectionSvg = document.getElementById('connectionSvg');
    let currentConnectionPath = null;
    let currentPulseDots = [];

    // Function to calculate connection path around session perimeter
    function calculateConnectionPath(chatElement, sessionElement) {
      const chatRect = chatElement.getBoundingClientRect();
      const sessionRect = sessionElement.getBoundingClientRect();
      const mainContentRect = mainContent.getBoundingClientRect();
      const overlayRect = connectionSvg.getBoundingClientRect();
      
      // Calculate positions relative to SVG overlay
      const chatRightX = chatRect.right - overlayRect.left;
      const chatCenterY = chatRect.top + chatRect.height / 2 - overlayRect.top;
      
      const sessionLeftX = sessionRect.left - overlayRect.left;
      const sessionRightX = sessionRect.right - overlayRect.left;
      const sessionTopY = sessionRect.top - overlayRect.top;
      const sessionBottomY = sessionRect.bottom - overlayRect.top;
      const sessionCenterY = sessionRect.top + sessionRect.height / 2 - overlayRect.top;
      
      const mainContentLeftX = mainContentRect.left - overlayRect.left;
      const mainContentRightX = mainContentRect.right - overlayRect.left;
      const mainContentTopY = mainContentRect.top - overlayRect.top;
      const mainContentBottomY = mainContentRect.bottom - overlayRect.top;
      
      // Calculate which edge of the session container to connect to
      const sessionCenterX = sessionRect.left + sessionRect.width / 2 - overlayRect.left;
      const isSessionOnLeft = sessionCenterX < mainContentLeftX + mainContentRect.width / 2;
      
      // Start from chat right edge
      let path = `M ${chatRightX} ${chatCenterY}`;
      
      // Move horizontally to the edge of the main content area
      const buffer = 7; // Buffer from the edge
      
      if (isSessionOnLeft) {
        // Session is on the left side of the main content area
        // Go to right edge of main content area first (outside)
        path += ` L ${mainContentLeftX - buffer} ${chatCenterY}`;
        
        // Then go up/down to session level (outside main content)
        if (sessionCenterY > chatCenterY) {
          // Session is below chat - go down
          path += ` L ${mainContentLeftX - buffer} ${sessionCenterY}`;
        } else {
          // Session is above chat - go up
          path += ` L ${mainContentLeftX - buffer} ${sessionCenterY}`;
        }
        
        // Then go to session left edge
        path += ` L ${sessionLeftX} ${sessionCenterY}`;
      } else {
        // Session is on the right side of the main content area
        // Go to left edge of main content area first (outside)
        path += ` L ${mainContentRightX + buffer} ${chatCenterY}`;
        
        // Then go up/down to session level (outside main content)
        if (sessionCenterY > chatCenterY) {
          // Session is below chat - go down
          path += ` L ${mainContentRightX + buffer} ${sessionCenterY}`;
        } else {
          // Session is above chat - go up
          path += ` L ${mainContentRightX + buffer} ${sessionCenterY}`;
        }
        
        // Then go to session right edge
        path += ` L ${sessionRightX} ${sessionCenterY}`;
      }
      
      return path;
    }

    // Function to draw connection line
    function drawConnectionLine(chatElement, sessionElement) {
      // Clear any existing connection
      clearConnectionLine();
      
      const pathData = calculateConnectionPath(chatElement, sessionElement);
      
      // Create SVG path
      currentConnectionPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      currentConnectionPath.setAttribute('d', pathData);
      currentConnectionPath.setAttribute('class', 'connection-path pulsating');
      
      // Use golden yellow color for user-assist mode, green for normal mode
      if (userAssistActive && userAssistTaskCard) {
        const sessionId = sessionElement.dataset.sessionId;
        const taskSessionId = userAssistTaskCard.dataset.sessionId;
        if (sessionId === taskSessionId) {
          currentConnectionPath.setAttribute('stroke', '#FFC107');
          currentConnectionPath.classList.add('user-assist');
        } else {
          currentConnectionPath.setAttribute('stroke', '#4CAF50');
        }
      } else {
        currentConnectionPath.setAttribute('stroke', '#4CAF50');
      }
      
      connectionSvg.appendChild(currentConnectionPath);
      
      // Create traveling pulse dots
      createPulseDots(pathData);
      
      console.log('Connection line drawn between chat and session');
    }

    // Function to create traveling pulse dots
    function createPulseDots(pathData) {
      // Create multiple pulse dots with staggered delays
      for (let i = 0; i < 3; i++) {
        const pulseDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        pulseDot.setAttribute('class', 'pulse-dot');
        pulseDot.setAttribute('r', '3');
        
        // Use golden yellow color for user-assist mode, green for normal mode
        if (userAssistActive && userAssistTaskCard && currentConnectionPath && currentConnectionPath.classList.contains('user-assist')) {
          pulseDot.setAttribute('fill', '#FFC107');
          pulseDot.classList.add('user-assist');
        } else {
          pulseDot.setAttribute('fill', '#4CAF50');
        }
        
        pulseDot.style.animationDelay = `${i * 0.3}s`;
        
        // Position the dot at the start of the path initially
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', pathData);
        const totalLength = path.getTotalLength();
        const point = path.getPointAtLength(0);
        
        pulseDot.setAttribute('cx', point.x);
        pulseDot.setAttribute('cy', point.y);
        
        connectionSvg.appendChild(pulseDot);
        currentPulseDots.push(pulseDot);
      }
    }

    // Function to clear connection line
    function clearConnectionLine() {
      if (currentConnectionPath) {
        connectionSvg.removeChild(currentConnectionPath);
        currentConnectionPath = null;
      }
      
      // Clear pulse dots
      currentPulseDots.forEach(dot => {
        if (dot.parentNode === connectionSvg) {
          connectionSvg.removeChild(dot);
        }
      });
      currentPulseDots = [];
    }

    // Function to update connection line when layout changes
    function updateConnectionLine() {
      if (selectedSessionId) {
        const session = sessions.get(selectedSessionId);
        const chatFieldset = document.getElementById('chatFieldset');
        
        if (session && chatFieldset) {
          drawConnectionLine(chatFieldset, session.container);
        }
      } else {
        clearConnectionLine();
      }
    }

    // Override selectSession function to handle connection lines
    const originalSelectSession = selectSession;
    selectSession = function(sessionId) {
      originalSelectSession(sessionId);
      updateConnectionLine();
    };

    // Override updateSessionLayout to handle connection lines on layout changes
    const originalUpdateSessionLayout = updateSessionLayout;
    updateSessionLayout = function() {
      originalUpdateSessionLayout();
      updateConnectionLine();
    };

    // Override closeSession to handle connection lines
    const originalCloseSession = closeSession;
    closeSession = function(sessionId) {
      originalCloseSession(sessionId);
      if (selectedSessionId === sessionId) {
        selectedSessionId = null;
        clearConnectionLine();
      }
    };

    // Initial connection line setup
    setTimeout(() => {
      if (selectedSessionId) {
        updateConnectionLine();
      }
    }, 100);

    // Handle window resize to update connection lines
    window.addEventListener('resize', () => {
      updateConnectionLine();
    });

    // Function to get scrollbar width
    function getScrollbarWidth() {
      // Create a temporary div to measure scrollbar width
      const outer = document.createElement('div');
      outer.style.visibility = 'hidden';
      outer.style.overflow = 'scroll';
      outer.style.width = '100px';
      outer.style.position = 'absolute';
      document.body.appendChild(outer);
      
      const inner = document.createElement('div');
      inner.style.width = '100%';
      outer.appendChild(inner);
      
      const scrollbarWidth = outer.offsetWidth - inner.offsetWidth;
      
      // Clean up
      outer.parentNode.removeChild(outer);
      
      return scrollbarWidth;
    }

    // Function to calculate user-assist connection path (straight line from task card to chat)
    function calculateUserAssistPath(taskCardElement, chatElement) {
      const taskRect = taskCardElement.getBoundingClientRect();
      const chatRect = chatElement.getBoundingClientRect();
      const overlayRect = connectionSvg.getBoundingClientRect();
      
      // Calculate center of chat fieldset
      const chatCenterX = chatRect.left + chatRect.width / 2 - overlayRect.left;
      const chatTopY = chatRect.top - overlayRect.top;
      
      // Draw straight line from chat center to bottom edge of task card
      const taskBottomY = taskRect.bottom - overlayRect.top;
      
      // Straight line from bottom edge of task card to top center of chat
      return `M ${chatCenterX} ${chatTopY} L ${chatCenterX} ${taskBottomY}`;
    }

    // Function to draw user-assist connection line
    function drawUserAssistConnectionLine(taskCardElement, chatElement) {
      // Clear any existing user-assist connection
      clearUserAssistConnectionLine();
      
      const pathData = calculateUserAssistPath(taskCardElement, chatElement);
      
      // Create SVG path
      userAssistConnectionPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      userAssistConnectionPath.setAttribute('d', pathData);
      userAssistConnectionPath.setAttribute('class', 'connection-path user-assist');
      userAssistConnectionPath.setAttribute('stroke', '#FFC107');
      
      connectionSvg.appendChild(userAssistConnectionPath);
      
      // Create traveling pulse dots
      createUserAssistPulseDots(pathData);
      
      console.log('User-assist connection line drawn');
    }

    // Function to update user-assist connection line
    function updateUserAssistConnectionLine() {
      if (userAssistActive && userAssistTaskCard) {
        const chatFieldset = document.getElementById('chatFieldset');
        drawUserAssistConnectionLine(userAssistTaskCard, chatFieldset);
      }
    }


    // Function to update connection line when layout changes
    function updateConnectionLine() {
      if (selectedSessionId) {
        const session = sessions.get(selectedSessionId);
        const chatFieldset = document.getElementById('chatFieldset');
        
        if (session && chatFieldset) {
          drawConnectionLine(chatFieldset, session.container);
        }
      } else {
        clearConnectionLine();
      }
      
      // Also update user-assist connection line if active
      updateUserAssistConnectionLine();
    }

    // Handle scroll to update connection lines
    window.addEventListener('scroll', () => {
      updateConnectionLine();
    }, { passive: true });

    // Handle tasks container scroll to update user-assist connection line
    const tasksContainer = document.getElementById('tasksContainer');
    if (tasksContainer) {
      tasksContainer.addEventListener('scroll', () => {
        updateUserAssistConnectionLine();
      }, { passive: true });
    }

    // Handle resize to update all connection lines
    window.addEventListener('resize', () => {
      updateConnectionLine();
    });
  </script>
</body>
</html>
