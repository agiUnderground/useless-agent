<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Screenshot App</title>
  <style>
    @font-face {
      font-family: 'JetBrains Mono';
      src: local('./fonts/webfonts/JetBrainsMono-Regular.woff2') format('woff2'),
           url('https://cdn.jsdelivr.net/gh/JetBrains/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2') format('woff2'),
           url('https://cdn.jsdelivr.net/gh/JetBrains/JetBrainsMono/web/woff/JetBrainsMono-Regular.woff') format('woff');
      font-display: swap;
      font-weight: 400;
      font-style: normal;
    }

    :root {
      --dot-bg: #000000de;
      --dot-color: #403f3f;
      --dot-size: 1px;
      --dot-space: 22px;
      --primary-bg: #212121;
      --border-color: #333333;
    }

    html, body {
      height: 100vh;
      width: 100vw;
      margin: 0;
      overflow: hidden;
      font-family: 'JetBrains Mono', monospace;
      color: white;
      background: linear-gradient(90deg, var(--dot-bg) calc(var(--dot-space) - var(--dot-size)), transparent 1%) center / var(--dot-space) var(--dot-space),
                  linear-gradient(var(--dot-bg) calc(var(--dot-space) - var(--dot-size)), transparent 1%) center / var(--dot-space) var(--dot-space),
                  var(--dot-color);
    }

    .main-wrapper {
      display: flex;
      height: 100vh;
      width: 100vw;
      gap: 20px;
      padding: 20px;
      box-sizing: border-box;
    }

    .toolbar {
      display: flex;
      flex-direction: column;
      width: 320px;
      min-width: 320px;
      gap: 10px;
      height: calc(100vh - 40px);
      /* overflow-y: auto; */
    }

    .main-content {
      flex: 1;
      min-width: 0;
      height: calc(100vh - 40px);
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .button-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .control-button {
      background-color: rgb(1, 1, 1);
      border: 1px solid var(--border-color);
      color: #6f6f6f;
      padding: 12px;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s ease;
      width: 100%;
      text-align: left;
    }

    .control-button:hover {
      background-color: #010b13;
    }

    .screenshot-img {
      /*max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      image-rendering: crisp-edges; */

      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
      /* object-fit: none; */
      object-fit: scale-down;
      flex-shrink: 0;
    }

    .input-group {
      display: flex;
      gap: 8px;
      width: 100%;
    }

    .coord-inputs {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .coord-input {
      width: 60px;
      padding: 6px;
      background: var(--primary-bg);
      border: 1px solid var(--border-color);
      color: white;
      border-radius: 4px;
    }

    .dark-textarea {
      background-color: var(--primary-bg);
      color: white;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 10px;
      resize: none;
      width: 100%;
      box-sizing: border-box;
    }

    #llmChatInput {
      height: 100%;
      margin-top: 0px;
    }

    #llmChatInput:focus {
      outline: none;
    }

    fieldset {
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 10px;
      margin: 0;
      position: relative;
    }

    #colorsList ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    #colorsList li {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }

    .color-square {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      border: 1px solid var(--border-color);
    }

    .scrollable {
      overflow-y: auto;
      flex: 1;
      min-height: 0;
    }

    /* Connection Status Indicator */
    .connection-status {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 8px;
      background-color: #666; /* Grey - inactive */
    }

    .connection-status.connected {
      background-color: #4CAF50; /* Green - connected */
      box-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
    }

    .connection-status.connecting {
      background-color: #FFC107; /* Yellow - connecting/error */
      box-shadow: 0 0 5px rgba(255, 193, 7, 0.5);
    }

    .connection-button {
      display: flex;
      align-items: center;
    }

    /* Hidden button group */
    .button-group.hidden {
      display: none;
    }

    /* Small toggle button */
    .toggle-buttons-btn {
      position: fixed;
      top: 5px;
      left: 5px;
      width: 10px;
      height: 10px;
      background-color: black; /* #333; */
      border: 1px solid #555;
      border-radius: 50%;
      cursor: pointer;
      z-index: 1000;
      padding: 0;
      margin: 0;
    }

    .toggle-buttons-btn:hover {
      background-color: #444;
    }

    /* FPS Button Styles */
    .fps-button {
      background-color: rgb(1, 1, 1);
      border: 1px solid var(--border-color);
      color: #6f6f6f;
      padding: 2px 6px;
      border-radius: 3px;
      cursor: pointer;
      transition: background-color 0.3s ease;
      font-size: 11px;
      height: 20px;
      min-width: 24px;
      flex: 1;
      text-align: center;
    }

    .fps-button:hover {
      background-color: #010b13;
    }

    .fps-button.active {
      background-color: #2a2a2a;
      color: #ffffff;
      border-color: #555555;
    }

    /* Debug Button Styles */
    .debug-button {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 10px;
      height: 10px;
      background-color: black;
      border: 1px solid #555;
      border-radius: 50%;
      cursor: pointer;
      padding: 0;
      margin: 0;
      z-index: 1;
    }

    .debug-button:hover {
      background-color: #444;
    }

    /* Screenshot placeholder styles */
    .screenshot-placeholder {
      display: flex;
      justify-content: center;
      align-items: center;
      color: #6f6f6f;
      font-size: 14px;
      text-align: center;
      width: 100%;
      height: 100%;
    }
    
    .screenshot-img.hidden {
      display: none;
    }
    
    .screenshot-placeholder.hidden {
      display: none;
    }

    /* Task Management Styles */
    .tasks-section {
      flex: 1;
      min-height: 0;
      display: flex;
      flex-direction: column;
      gap: 10px;
      transition: all 0.3s ease;
      max-height: 0;
      opacity: 0;
      transform: translateY(20px);
    }
    
    .tasks-section fieldset {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
      overflow: hidden;
      padding-right: 0px;
      padding-bottom: 0px;
      padding-top: 0px;
    }
    
    /* Ensure tasks container is scrollable */
    #tasksContainer {
      overflow-y: auto;
      flex: 1;
      min-height: 0;
      padding: 15px;
      
      /* Custom scrollbar styling */
      scrollbar-width: thin;
      scrollbar-color: #555 #212121;
    }
    
    /* Webkit browsers (Chrome, Safari, Edge) */
    #tasksContainer::-webkit-scrollbar {
      width: 6px;
    }
    
    #tasksContainer::-webkit-scrollbar-track {
      background: #212121;
      border-radius: 3px;
    }
    
    #tasksContainer::-webkit-scrollbar-thumb {
      background: #444;
      border-radius: 3px;
    }
    
    #tasksContainer::-webkit-scrollbar-thumb:hover {
      background: #666;
    }
    
    /* Firefox */
    #tasksContainer {
      scrollbar-width: thin;
      scrollbar-color: #444 #212121;
    }

    .tasks-section.visible {
      max-height: fit-content;
      opacity: 1;
      transform: translateY(0);
    }

    .task-card {
      background-color: var(--primary-bg);
      border: 2px solid;
      border-radius: 8px;
      padding: 12px;
      position: relative;
      animation: waveOutline 3s ease-in-out infinite;
      transition: all 0.3s ease;
      margin-top: 4px;
      margin-bottom: 4px;
    }

    @keyframes waveOutline {
      0% {
        box-shadow: 0 0 5px currentColor, 0 0 10px rgba(255, 255, 255, 0.1);
        border-color: currentColor;
      }
      50% {
        box-shadow: 0 0 20px currentColor, 0 0 30px rgba(255, 255, 255, 0.2);
        border-color: rgba(255, 255, 255, 0.8);
      }
      100% {
        box-shadow: 0 0 5px currentColor, 0 0 10px rgba(255, 255, 255, 0.1);
        border-color: currentColor;
      }
    }

    .task-card.in-progress {
      border-color: #FFC107;
      color: #FFC107;
    }

    .task-card.completed {
      border-color: #4CAF50;
      color: #4CAF50;
    }

    .task-card.broken {
      border-color: #F44336;
      color: #F44336;
    }

    .task-card.canceled {
      border-color: #9E9E9E;
      color: #9E9E9E;
    }

    .task-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .task-status {
      font-size: 12px;
      font-weight: bold;
      text-transform: uppercase;
    }

    .task-cancel-btn {
      background: none;
      border: 1px solid currentColor;
      color: currentColor;
      border-radius: 4px;
      padding: 4px 8px;
      cursor: pointer;
      font-size: 11px;
      transition: all 0.2s ease;
    }

    .task-cancel-btn:hover:not(:disabled) {
      /* background-color: currentColor; */
      color: white;
    }

    .task-cancel-btn:disabled {
      cursor: not-allowed;
      opacity: 0.6;
    }

    .task-message {
      font-size: 12px;
      line-height: 1.4;
      word-wrap: break-word;
      max-height: 60px;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Info icon for completed, broken, and canceled tasks */
    .task-info-icon {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background-color: #555;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: bold;
      cursor: default;
      z-index: 10;
      border: 1px solid rgba(255, 255, 255, 0.3);
      transition: all 0.2s ease;
    }

    .task-info-icon:hover {
      background-color: #777;
      transform: scale(1.1);
    }

    /* Timer for in-progress tasks */
    .task-timer {
      /* position: absolute; */
      top: 8px;
      right: 30px;
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 11px;
      color: #FFC107;
    }

    /* Timer colors for different statuses */
    .task-card.completed .task-timer {
      color: #66BB6A; /* Lighter green */
    }

    .task-card.broken .task-timer {
      color: #EF5350; /* Lighter red */
    }

    .task-card.canceled .task-timer {
      color: #BDBDBD; /* Lighter gray */
    }

    .sandwatch-icon {
      font-size: 12px;
    }


    .chat-fieldset.shrunk {
      /* flex: 1.5 !important; */
      flex: 1 !important;
      transition: flex 0.3s ease;
    }

    /* Screenshot container and overlay styles */
    .screenshot-container {
      position: relative;
      display: inline-flex;
      justify-content: center;
      align-items: center;
      max-width: 100%;
      max-height: 100%;
    }

    /* Invisible container that matches image size exactly */
    .image-size-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none; /* Allow clicks to pass through to the image */
    }

    .screenshot-overlay {
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      height: 30px;
      background-color: rgba(0, 0, 0, 0.3); /* More transparent (30% instead of 85%) */
      display: flex;
      align-items: center;
      justify-content: flex-end;
      padding: 0 10px;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none; /* Allow clicks to pass through to the image */
      width: 100%; /* Use full width of the invisible container */
      z-index: 1000; /* Ensure it's above the image */
    }
    
    /* Fullscreen mode - overlay should span full width */
    .screenshot-container:fullscreen .screenshot-overlay,
    .screenshot-container:-webkit-full-screen .screenshot-overlay,
    .screenshot-container:-moz-full-screen .screenshot-overlay,
    .screenshot-container:-ms-fullscreen .screenshot-overlay {
      position: fixed !important; /* Make overlay fixed to viewport in fullscreen */
      width: 100vw !important; /* Force full screen width */
      left: 0 !important;
      bottom: 0 !important;
      transform: none !important;
      justify-content: flex-end;
      padding-right: 20px;
      z-index: 9999; /* Ensure it's above everything */
    }
    
    /* Fullscreen mode - make image-size-container span full width */
    :fullscreen .image-size-container,
    :-webkit-full-screen .image-size-container,
    :-moz-full-screen .image-size-container,
    :-ms-fullscreen .image-size-container {
      width: 100vw !important; /* Force full screen width */
      height: 100vh !important; /* Force full screen height */
      position: fixed !important;
      top: 0 !important;
      left: 0 !important;
    }
    
    /* Fix positioning to ensure overlay is at the bottom of the image */
    .screenshot-container {
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    .screenshot-img {
      display: block; /* Ensure image is treated as a block element */
    }
    

    .fullscreen-button {
      background: none;
      border: none;
      color: white;
      cursor: pointer;
      padding: 4px;
      border-radius: 3px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background-color 0.2s ease;
    }

    .fullscreen-button:hover {
      background-color: rgba(255, 255, 255, 0.2);
    }

    .fullscreen-button svg {
      width: 16px;
      height: 16px;
    }

    /* Focus indicator for screenshot container */
    .screenshot-container.focused {
      outline: 2px solid rgba(255, 255, 255, 0.5);
      outline-offset: 2px;
    }
    
    .screenshot-container.focused .screenshot-overlay {
      opacity: 1;
      pointer-events: auto;
    }

    /* Fullscreen styling - center image and make it fit content */
    .screenshot-container:fullscreen {
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: black;
      width: 100vw;
      height: 100vh;
    }
    
    .screenshot-container:fullscreen .screenshot-img {
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
      object-fit: contain;
    }
    
    /* Vendor prefixes for fullscreen */
    .screenshot-container:-webkit-full-screen {
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: black;
      width: 100vw;
      height: 100vh;
    }
    
    .screenshot-container:-webkit-full-screen .screenshot-img {
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
      object-fit: contain;
    }
    
    .screenshot-container:-moz-full-screen {
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: black;
      width: 100vw;
      height: 100vh;
    }
    
    .screenshot-container:-moz-full-screen .screenshot-img {
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
      object-fit: contain;
    }
    
    .screenshot-container:-ms-fullscreen {
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: black;
      width: 100vw;
      height: 100vh;
    }
    
    .screenshot-container:-ms-fullscreen .screenshot-img {
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
      object-fit: contain;
    }

  </style>
</head>
<body>
  <div class="main-wrapper">
    <div class="toolbar">
      <div class="button-group hidden" id="mediaButtonsGroup">
        <button class="control-button" id="screenshotBtn">Take Screenshot</button>
        <button class="control-button" id="videoBtn">Video</button>
        <button class="control-button" id="video2">Video 2</button>
        <button class="control-button" id="popOutWSButton">Pop Out WS</button>
      </div>

      <fieldset>
        <legend>Connection</legend>
        
        <!-- Debug Button positioned at top right -->
        <button class="debug-button" id="toggleButtonsBtn" title="Debug"></button>
        
        <!-- FPS Selection -->
        <div class="fps-selector" style="margin-bottom: 10px;">
          <label style="display: block; margin-bottom: 4px; font-size: 12px; color: #6f6f6f;">FPS</label>
          <div class="fps-buttons" style="display: flex; gap: 4px; height: 20px;">
            <button class="fps-button" data-fps="1">1</button>
            <button class="fps-button" data-fps="5">5</button>
            <button class="fps-button" data-fps="10">10</button>
            <button class="fps-button" data-fps="15">15</button>
            <button class="fps-button" data-fps="30">30</button>
          </div>
        </div>

        <div class="input-group">
          <input type="text" id="ipv4" class="dark-textarea" 
                 placeholder="IP Address" 
                 pattern="^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$|^[\da-fA-F:]+$"
                 oninput="this.value=this.value.replace(/[^0-9a-fA-F.:]/g,'')" required>
          <button class="control-button connection-button" id="setTargetIP">
            <span class="connection-status" id="connectionStatus"></span>
            Connect
          </button>
        </div>
        
      </fieldset>

      <fieldset>
        <legend>Mouse Control</legend>
        <div class="coord-inputs">
          <input type="text" id="x-coord" class="coord-input"
                 placeholder="X"
                 pattern="-?[0-9]+"
                 title="Please enter a valid coordinate value."
                 oninput="this.value = this.value.replace(/[^-0-9]/g, '')" required>
          <input type="text" id="y-coord" class="coord-input"
                 placeholder="Y"
                 pattern="-?[0-9]+"
                 title="Please enter a valid coordinate value."
                 oninput="this.value = this.value.replace(/[^-0-9]/g, '')" required>
          <button class="control-button" id="sendMouseInput">Move</button>
          <button class="control-button" id="sendMouseClick">Click</button>
        </div>
      </fieldset>

      <fieldset>
        <legend>Status</legend>
        <p style="margin: auto; font-size: 12px; padding: 5px; width: fit-content;">Total tokens used: <span id="tokenCounter">0</span></p>
      </fieldset>

      <div id="tasksSection" class="tasks-section">
        <fieldset>
          <legend>Tasks</legend>
          <div id="tasksContainer"></div>
        </fieldset>
      </div>

      <fieldset id="chatFieldset" style="flex: 3; display: flex; flex-direction: column; min-height: 200px;" class="chat-fieldset">
        <legend>Chat</legend>
        <textarea id="llmChatInput" class="dark-textarea" placeholder="Type a message..." spellcheck="false" autocorrect="off" autocapitalize="off" autocomplete="off"></textarea>
        <button class="control-button" id="llmSendButton" style="margin-top: 10px;">Send</button>
      </fieldset>
    </div>

    <div class="main-content">
      <div id="screenshotPlaceholder" class="screenshot-placeholder">Video stream will appear here</div>
      <div class="screenshot-container">
        <img id="screenshotImg" class="screenshot-img hidden" src="" alt="Video stream">
        <!-- Invisible container that matches image size for proper overlay positioning -->
        <div class="image-size-container" id="imageSizeContainer">
          <!-- Overlay positioned at bottom of invisible container -->
          <div class="screenshot-overlay" id="screenshotOverlay">
            <button class="fullscreen-button" id="fullscreenBtn" title="Toggle fullscreen">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
              </svg>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    let ip = "127.0.0.1";
    let ws = null;
    let videoLoopInterval = null;
    let popOutWSWindow = null;
    const screenshotImg = document.getElementById('screenshotImg');
    const screenshotPlaceholder = document.getElementById('screenshotPlaceholder');
    // Image Fetch Functions
    let currentVideoSession = 0;
    let isConnected = false;
    let buttonsVisible = false;
    let currentFPS = 5; // Default FPS
    // Task Management
    let currentTask = null;
    let isFirstMessage = true;
    
    // Show placeholder initially
    screenshotPlaceholder.classList.remove('hidden');
    screenshotImg.classList.add('hidden');
    

    // Toggle buttons functionality
    function toggleMediaButtons() {
      const mediaButtonsGroup = document.getElementById('mediaButtonsGroup');
      buttonsVisible = !buttonsVisible;
      
      if (buttonsVisible) {
        mediaButtonsGroup.classList.remove('hidden');
      } else {
        mediaButtonsGroup.classList.add('hidden');
      }
    }

    // Update connection button text and functionality
    function updateConnectionButton() {
      const connectButton = document.getElementById('setTargetIP');
      
      if (isConnected) {
        // Change to Disconnect
        connectButton.innerHTML = '<span class="connection-status" id="connectionStatus"></span> Disconnect';
      } else {
        // Change to Connect
        connectButton.innerHTML = '<span class="connection-status" id="connectionStatus"></span> Connect';
      }
      
      // Update the connection status after changing the HTML
      updateConnectionStatus(isConnected ? 'connected' : 'disconnected');
    }

    // Connection Status Management
    function updateConnectionStatus(status) {
      const statusElement = document.getElementById('connectionStatus');
      statusElement.className = 'connection-status';
      
      switch(status) {
        case 'connected':
          statusElement.classList.add('connected');
          break;
        case 'connecting':
          statusElement.classList.add('connecting');
          break;
        case 'disconnected':
          // Default grey color (inactive)
          break;
      }
    }

    // WebSocket Management
    function setupWebSocket() {
      if (ws) ws.close();
      updateConnectionStatus('connecting');
      isConnected = false;
      updateConnectionButton();
      
      ws = new WebSocket(`ws://${ip}:8080/ws`);

      ws.onopen = () => {
        console.log("Connected to server");
        updateConnectionStatus('connected');
        isConnected = true;
        updateConnectionButton();
        
        // Automatically start video when connection is established
        const videoBtn = document.getElementById('videoBtn');
        if (videoBtn && !videoLoopInterval) {
          toggleVideoLoop(() => fetchImage('screenshot'), videoBtn, videoBtn.textContent.replace('Stop ', ''));
        }
      };
      
      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          console.log('WebSocket message received:', data);
          
          if (data.type === 'tokenUpdate') {
            document.getElementById('tokenCounter').textContent = data.total;
          } else if (data.type === 'taskUpdate') {
            handleTaskUpdate(data);
          } else {
            console.log('Unknown message type:', data.type);
          }
        } catch (error) {
          // Handle non-JSON messages or other WebSocket messages
          console.log('WebSocket message (non-JSON):', event.data);
        }
      };
      
      ws.onclose = () => {
        console.log("Disconnected from server");
        updateConnectionStatus('disconnected');
        isConnected = false;
        updateConnectionButton();
      };
      
      ws.onerror = (error) => {
        console.error("WebSocket error:", error);
        updateConnectionStatus('connecting'); // Show yellow for connection problems
        isConnected = false;
        updateConnectionButton();
      };
    }

    // Disconnect WebSocket
    function disconnectWebSocket() {
      if (ws) {
        ws.close();
        updateConnectionStatus('disconnected');
        isConnected = false;
        updateConnectionButton();
      }
      
      // Stop video stream when disconnecting
      if (videoLoopInterval) {
        clearInterval(videoLoopInterval);
        videoLoopInterval = null;
        
        // Reset video button texts
        const videoBtn = document.getElementById('videoBtn');
        const video2Btn = document.getElementById('video2');
        if (videoBtn) videoBtn.textContent = 'Video';
        if (video2Btn) video2Btn.textContent = 'Video 2';
      }
    }

    // Generic Functions
    function prettifyJSON(input) {
      try {
        return JSON.stringify(JSON.parse(input), null, 4);
      } catch {
        return input;
      }
    }

    function toggleVideoLoop(fetchFunction, button, buttonText) {
      if (videoLoopInterval) {
        clearInterval(videoLoopInterval);
        videoLoopInterval = null;
        button.textContent = buttonText;
        currentVideoSession = 0
      } else {
        currentVideoSession = button.id === 'videoBtn' ? 1 : button.id === 'video2' ? 2 : 0;
        videoLoopInterval = setInterval(fetchFunction, 1000 / currentFPS);
        button.textContent = `Stop ${buttonText}`;
      }
    }

    // FPS Selection Function
    function setFPS(fps) {
      currentFPS = fps;
      
      // Update button states
      document.querySelectorAll('.fps-button').forEach(btn => {
        if (parseInt(btn.dataset.fps) === fps) {
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      });
      
      // If video is currently streaming, restart it with new FPS
      if (videoLoopInterval) {
        // Find which video button is active and restart it
        const videoControls = {
          videoBtn: 'screenshot',
          video2: 'video2'
        };
        
        Object.entries(videoControls).forEach(([id, endpoint]) => {
          const btn = document.getElementById(id);
          if (btn && btn.textContent.includes('Stop')) {
            clearInterval(videoLoopInterval);
            videoLoopInterval = setInterval(() => fetchImage(endpoint), 1000 / currentFPS);
          }
        });
      }
      
      console.log(`FPS set to: ${currentFPS}`);
    }

    async function fetchImage(endpoint) {
      // Store session ID when request starts
      const thisSession = currentVideoSession;
      
      try {
        const response = await fetch(`http://${ip}:8080/${endpoint}`);
        if (!response.ok) throw new Error(`Failed to fetch ${endpoint}`);

        // Check if video was stopped while request was in flight
        if (thisSession !== currentVideoSession) {
          return; // Discard this image
        }

        const blob = await response.blob();
        const imageUrl = URL.createObjectURL(blob);
        if (screenshotImg.src) URL.revokeObjectURL(screenshotImg.src);
        screenshotImg.src = imageUrl;
        
        // Update invisible container to match image size only once when first image loads
        let containerSizeSet = false;
        screenshotImg.onload = function() {
          const imageSizeContainer = document.getElementById('imageSizeContainer');
          
          // Only set container size once, not on every image load
          if (!containerSizeSet) {
            // Check if we're in fullscreen mode - if so, don't set fixed sizes
            const isFullscreen = document.fullscreenElement || 
                                document.webkitFullscreenElement || 
                                document.mozFullScreenElement || 
                                document.msFullscreenElement;
            
            if (!isFullscreen) {
              imageSizeContainer.style.width = this.width + 'px';
              imageSizeContainer.style.height = this.height + 'px';
              containerSizeSet = true;
            }
          }
        };
        
        // Show image and hide placeholder
        screenshotImg.classList.remove('hidden');
        screenshotPlaceholder.classList.add('hidden');
      } catch (error) {
        console.error('Error:', error);
        // Show placeholder and hide image on error
        screenshotImg.classList.add('hidden');
        screenshotPlaceholder.classList.remove('hidden');
      }
    }

    // Mouse Functions
    async function sendMouseClick() {
      try {
        const response = await fetch(`http://${ip}:8080/mouse-click`);
        if (!response.ok) throw new Error('Failed to send mouse click');
      } catch (error) {
        console.error('Error:', error);
      }
    }

    async function sendMouseInput() {
      const x = document.getElementById('x-coord').value;
      const y = document.getElementById('y-coord').value;
      try {
        const response = await fetch(`http://${ip}:8080/mouse-input?x=${x}&y=${y}`);
        if (!response.ok) throw new Error('Failed to send mouse input');
      } catch (error) {
        console.error('Error:', error);
      }
    }

    function formatIp(ip) {
      if (ip.includes(':')) {
        return `[${ip}]`;
      } else {
        return `${ip}`;
      }
    }

    // Event Listeners
    document.getElementById("setTargetIP").addEventListener("click", () => {
      if (isConnected) {
        disconnectWebSocket();
      } else {
        ip = formatIp(document.getElementById('ipv4').value);
        console.log("Target IP changed to", ip);
        currentVideoSession += 1;
        setupWebSocket();
      }
    });

    // Toggle button event listener
    document.getElementById("toggleButtonsBtn").addEventListener("click", toggleMediaButtons);

    document.getElementById("screenshotBtn").addEventListener("click", () => fetchImage('screenshot'));
    document.getElementById("sendMouseClick").addEventListener("click", sendMouseClick);
    document.getElementById("sendMouseInput").addEventListener("click", sendMouseInput);

    // Video Controls
    const videoControls = {
      videoBtn: 'screenshot',
      video2: 'video2'
    };

    Object.entries(videoControls).forEach(([id, endpoint]) => {
      document.getElementById(id).addEventListener('click', function() {
        toggleVideoLoop(() => fetchImage(endpoint), this, this.textContent.replace('Stop ', ''));
      });
    });

    // Task Management Functions
    function createTaskCard(message, status = 'in-progress') {
      const taskCard = document.createElement('div');
      taskCard.className = `task-card ${status}`;
      
      // Store original message as data attribute for later reference
      taskCard.dataset.originalMessage = message;
      
      const taskHeader = document.createElement('div');
      taskHeader.className = 'task-header';
      
      const taskStatus = document.createElement('span');
      taskStatus.className = 'task-status';
      taskStatus.textContent = status === 'in-progress' ? 'In Progress' : 
                             status === 'completed' ? 'Completed' :
                             status === 'broken' ? 'Broken' : 'Canceled';
      
      const cancelBtn = document.createElement('button');
      cancelBtn.className = 'task-cancel-btn';
      cancelBtn.textContent = 'Cancel';
      cancelBtn.addEventListener('click', () => {
        cancelTask(taskCard);
      });
      
      const taskMessage = document.createElement('div');
      taskMessage.className = 'task-message';
      taskMessage.textContent = message.length > 100 ? message.substring(0, 100) + '...' : message;
      
      taskHeader.appendChild(taskStatus);
      taskHeader.appendChild(cancelBtn);
      taskCard.appendChild(taskHeader);
      taskCard.appendChild(taskMessage);
      
      // Add timer for in-progress tasks
      if (status === 'in-progress') {
        const timerContainer = document.createElement('div');
        timerContainer.className = 'task-timer';
        
        //const sandwatchIcon = document.createElement('span');
        //sandwatchIcon.className = 'sandwatch-icon';
        //sandwatchIcon.textContent = 'â³' ;
        
        const timerText = document.createElement('span');
        timerText.className = 'timer-text';
        timerText.textContent = '00:00:00:00:000';
        
        //timerContainer.appendChild(sandwatchIcon);
        timerContainer.appendChild(timerText);
        taskCard.appendChild(timerContainer);
        
        // Store creation time for timer
        taskCard.dataset.createdAt = Date.now();
        
        // Start timer
        startTaskTimer(taskCard);
      }
      
      // Add info icon for all statuses except 'in-progress'
      if (status !== 'in-progress') {
        const infoIcon = document.createElement('div');
        infoIcon.className = 'task-info-icon';
        infoIcon.textContent = '?';
        infoIcon.title = taskCard.dataset.originalMessage;
        
        taskCard.appendChild(infoIcon);
      }
      
      return taskCard;
    }
    
    function startTaskTimer(taskCard) {
      const timerElement = taskCard.querySelector('.timer-text');
      if (!timerElement) return;
      
      const createdAt = parseInt(taskCard.dataset.createdAt);
      const timerInterval = setInterval(() => {
        const elapsed = Date.now() - createdAt;
        timerElement.textContent = formatElapsedTime(elapsed);
      }, 10); // Update every 10ms for milliseconds precision
      
      // Store interval ID for cleanup
      taskCard.dataset.timerInterval = timerInterval;
    }
    
    function stopTaskTimer(taskCard) {
      const intervalId = taskCard.dataset.timerInterval;
      if (intervalId) {
        clearInterval(intervalId);
        delete taskCard.dataset.timerInterval;
      }
    }
    
    function formatElapsedTime(milliseconds) {
      const days = Math.floor(milliseconds / (1000 * 60 * 60 * 24));
      const hours = Math.floor((milliseconds % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
      const minutes = Math.floor((milliseconds % (1000 * 60 * 60)) / (1000 * 60));
      const seconds = Math.floor((milliseconds % (1000 * 60)) / 1000);
      const ms = milliseconds % 1000;
      
      return `${days.toString().padStart(2, '0')}:${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}:${ms.toString().padStart(3, '0')}`;
    }
    
    function showTasksSection() {
      const tasksSection = document.getElementById('tasksSection');
      const chatFieldset = document.getElementById('chatFieldset');
      
      // Show tasks section with flexible sizing
      tasksSection.classList.add('visible');
      
      // Calculate dynamic flex value based on tasks content
      const tasksContainer = document.getElementById('tasksContainer');
      const taskCount = tasksContainer.children.length;
      const dynamicFlex = Math.max(1.5, 3 - (taskCount * 0.3)); // Adjust flex based on task count
      
      // Apply dynamic flex to chat section
      chatFieldset.style.flex = `${dynamicFlex}`;
    }
    
    function cancelTask(taskCard) {
      const taskId = taskCard.dataset.taskId;
      if (!taskId) return;
      
      // Send cancellation request to backend
      fetch(`http://${ip}:8080/task-cancel?taskId=${taskId}`)
        .then(response => response.json())
        .then(data => {
          console.log('Task cancellation response:', data);
          
          // Update UI based on backend response
          if (data.result === 'Task canceled successfully') {
            taskCard.classList.remove('in-progress');
            taskCard.classList.add('canceled');
            
            const statusElement = taskCard.querySelector('.task-status');
            statusElement.textContent = 'Canceled';
            
            // Remove cancel button
            const cancelBtn = taskCard.querySelector('.task-cancel-btn');
            if (cancelBtn) {
              cancelBtn.remove();
            }
            
            // Update current task status
            if (currentTask === taskCard) {
              currentTask = null;
            }
          }
        })
        .catch(error => {
          console.error('Error canceling task:', error);
        });
    }
    
    function handleTaskUpdate(data) {
      console.log('Task update received:', data);
      
      // Debug: Check if we have the expected data structure
      if (!data.taskId || !data.status) {
        console.error('Invalid task update data:', data);
        return;
      }
      
      const tasksContainer = document.getElementById('tasksContainer');
      const taskCards = tasksContainer.querySelectorAll('.task-card');
      
      // First, check if we have a pending task that needs to be updated with real task ID
      let taskCard = null;
      for (const card of taskCards) {
        if (card.dataset.taskId === 'pending') {
          // Found a pending task - update it with the real task ID
          card.dataset.taskId = data.taskId;
          
          // Enable cancel button now that we have a real task ID
          const cancelBtn = card.querySelector('.task-cancel-btn');
          if (cancelBtn) {
            cancelBtn.disabled = false;
            cancelBtn.textContent = 'Cancel';
          }
          
          taskCard = card;
          break;
        } else if (card.dataset.taskId === data.taskId) {
          taskCard = card;
          break;
        }
      }
      
      if (!taskCard) {
        // Create new task card if it doesn't exist
        taskCard = createTaskCard(data.message, data.status);
        taskCard.dataset.taskId = data.taskId;
        tasksContainer.appendChild(taskCard);
        
        // Show tasks section if it's the first task
        if (tasksContainer.children.length === 1) {
          showTasksSection();
        }
      } else {
        // Update existing task card
        console.log('Updating task card with status:', data.status);
        
        // Remove all status classes first
        taskCard.classList.remove('in-progress', 'completed', 'broken', 'canceled');
        // Add the new status class based on the status field
        taskCard.classList.add(data.status);
        
        const statusElement = taskCard.querySelector('.task-status');
        const messageElement = taskCard.querySelector('.task-message');
        
        if (statusElement) {
          statusElement.textContent = data.status === 'in-progress' ? 'In Progress' : 
                                    data.status === 'completed' ? 'Completed' :
                                    data.status === 'broken' ? 'Broken' : 'Canceled';
        }
        
        if (messageElement && data.message) {
          messageElement.textContent = data.message.length > 100 ? 
                                     data.message.substring(0, 100) + '...' : data.message;
        }
        
        // Remove cancel button if task is completed, broken, or canceled
        if (data.status !== 'in-progress') {
          const cancelBtn = taskCard.querySelector('.task-cancel-btn');
          if (cancelBtn) {
            cancelBtn.remove();
          }
        }
        
        // Add or remove info icon based on new status
        const existingInfoIcon = taskCard.querySelector('.task-info-icon');
        
        if (data.status !== 'in-progress') {
          // Add info icon if it doesn't exist
          if (!existingInfoIcon) {
            const infoIcon = document.createElement('div');
            infoIcon.className = 'task-info-icon';
            infoIcon.textContent = '?';
            infoIcon.title = taskCard.dataset.originalMessage;
            
            taskCard.appendChild(infoIcon);
          } else {
            // Update title if info icon already exists
            existingInfoIcon.title = taskCard.dataset.originalMessage;
          }
        } else {
          // Remove info icon if status is 'in-progress'
          if (existingInfoIcon) {
            existingInfoIcon.remove();
          }
        }
        
        // Stop timer if task is no longer in progress
        if (data.status !== 'in-progress') {
          stopTaskTimer(taskCard);
        }
      }
      
      // Update current task reference
      if (data.status === 'in-progress') {
        currentTask = taskCard;
      } else if (currentTask === taskCard) {
        currentTask = null;
      }
      
      // Scroll to bottom to show the updated/created task
      setTimeout(scrollTasksToBottom, 0);
    }

    function scrollTasksToBottom() {
      const tasksContainer = document.getElementById('tasksContainer');
      if (tasksContainer) {
        tasksContainer.scrollTop = tasksContainer.scrollHeight;
      }
    }

    function handleTaskCreation(message) {
      if (isFirstMessage) {
        // Create task card immediately for first message with temporary ID
        const tasksContainer = document.getElementById('tasksContainer');
        tasksContainer.innerHTML = ''; // Clear any existing tasks
        
        const taskCard = createTaskCard(message);
        taskCard.dataset.taskId = 'pending'; // Temporary ID until we get real one
        tasksContainer.appendChild(taskCard);
        currentTask = taskCard;
        
        // Disable cancel button until we get real task ID
        const cancelBtn = taskCard.querySelector('.task-cancel-btn');
        if (cancelBtn) {
          cancelBtn.disabled = true;
          cancelBtn.textContent = 'Cancel';
        }
        
        // Show tasks section
        showTasksSection();
        
        // Scroll to bottom to show the new task
        setTimeout(scrollTasksToBottom, 0);
        
        isFirstMessage = false;
      } else {
        // For subsequent messages, just send them as user help (no visual task card)
        console.log('User help message:', message);
      }
    }

    // LLM Chat
    document.getElementById("llmSendButton").addEventListener("click", () => {
      const inputText = document.getElementById('llmChatInput').value;
      if (!inputText) return;

      fetch(`http://${ip}:8080/llm-input`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text: inputText })
      }).catch(error => {
        console.error('Error:', error);
      });

      // Handle task creation
      handleTaskCreation(inputText);
      
      document.getElementById('llmChatInput').value = "";
    });

    // Hotkey functionality for chat input
    document.getElementById("llmChatInput").addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        if (event.shiftKey) {
          // Shift+Enter - allow default behavior (new line)
          return;
        } else {
          // Enter without Shift - send message if input is not empty
          event.preventDefault();
          const inputText = document.getElementById('llmChatInput').value.trim();
          if (inputText) {
            document.getElementById("llmSendButton").click();
          }
        }
      }
    });

    // Pop Out WS
    document.getElementById("popOutWSButton").addEventListener("click", function() {
      // Open window with specific features for better visibility
      popOutWSWindow = window.open('', '_blank', 'width=800,height=600,resizable=yes,scrollbars=yes');

      if (popOutWSWindow) {
        const html = `<!DOCTYPE html>
<html>
<head>
  <title>WebSocket Output</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      background-color: #1e1e1e;
      color: #fff;
      font-family: monospace;
    }
    #poppedTextarea {
      width: 100%;
      height: calc(100vh - 40px);
      background-color: #000;
      color: #fff;
      border: 1px solid #333;
      padding: 10px;
      font-size: 14px;
      line-height: 1.4;
      resize: none;
      box-sizing: border-box;
    }
  </style>
</head>
<body>
  <textarea id="poppedTextarea" readonly></textarea>
  <script>
    // Debug logging
    console.log('Pop-out window loaded');
    
    const ip = '${ip}';
    let ws = null;
    const textarea = document.getElementById('poppedTextarea');
    
    function log(msg) {
      console.log(msg);
      textarea.value += msg + '\\n';
      textarea.scrollTop = textarea.scrollHeight;
    }

    function setupWebSocket() {
      try {
        log('Attempting WebSocket connection...');
        
        ws = new WebSocket('ws://' + ip + ':8080/ws');
        
        ws.onopen = () => {
          log('Connected to WebSocket server');
        };
        
        ws.onmessage = (event) => {
          if (!event.data) return;
          
          try {
            const parsed = JSON.parse(event.data);
            const formatted = JSON.stringify(parsed, null, 2);
            log('Received: ' + formatted);
          } catch (e) {
            log('Received: ' + event.data);
          }
        };

        ws.onclose = () => {
          log('WebSocket connection closed');
          ws = null;
          // Try to reconnect after 3 seconds
          setTimeout(setupWebSocket, 3000);
        };

        ws.onerror = (error) => {
          log('WebSocket error: ' + error.message);
        };

      } catch (error) {
        log('Setup error: ' + error.message);
      }
    }

    // Start connection when window loads
    window.addEventListener('load', setupWebSocket);
  <\/script>
</body>
</html>`;

        // Write the HTML and explicitly close the document
        popOutWSWindow.document.open();
        popOutWSWindow.document.write(html);
        popOutWSWindow.document.close();

        // Log success in main window
        console.log('Pop-out window created successfully');
      } else {
        console.error('Failed to create pop-out window');
      }
    });
    
    // FPS Button Event Listeners
    document.querySelectorAll('.fps-button').forEach(button => {
      button.addEventListener('click', function() {
        const fps = parseInt(this.dataset.fps);
        setFPS(fps);
      });
    });

    // Initialize default FPS state
    setFPS(currentFPS);
    
    // Initial WebSocket setup for main window
    setupWebSocket();
    
    // Fullscreen functionality
    const fullscreenBtn = document.getElementById('fullscreenBtn');
    const screenshotContainer = document.querySelector('.screenshot-container');
    const llmChatInput = document.getElementById('llmChatInput');
    const screenshotOverlay = document.querySelector('.screenshot-overlay');
    
    // Inactivity timer for overlay
    let overlayTimeout = null;
    const OVERLAY_TIMEOUT = 3000; // 3 seconds
    
    function resetOverlayTimer() {
      // Clear existing timeout
      if (overlayTimeout) {
        clearTimeout(overlayTimeout);
      }
      
      // Only set timeout if in fullscreen mode
      const isFullscreen = document.fullscreenElement || 
                          document.webkitFullscreenElement || 
                          document.mozFullScreenElement || 
                          document.msFullscreenElement;
      
      if (isFullscreen) {
        // Show overlay immediately when activity is detected
        screenshotOverlay.style.opacity = '1';
        screenshotOverlay.style.pointerEvents = 'auto';
        
        // Set new timeout to hide overlay after inactivity
        overlayTimeout = setTimeout(() => {
          screenshotOverlay.style.opacity = '0';
          screenshotOverlay.style.pointerEvents = 'none';
        }, OVERLAY_TIMEOUT);
      }
    }
    
    
    // Mouse event handling for overlay
    let isMouseOverOverlay = false;
    let isMouseOverContainer = false;
    
    // Handle mouse enter on overlay
    screenshotOverlay.addEventListener('mouseenter', () => {
      isMouseOverOverlay = true;
      if (overlayTimeout) {
        clearTimeout(overlayTimeout);
      }
    });
    
    // Handle mouse leave from overlay
    screenshotOverlay.addEventListener('mouseleave', () => {
      isMouseOverOverlay = false;
      // Only hide if mouse is not over container either
      if (!isMouseOverContainer) {
        const isFullscreen = document.fullscreenElement || 
                            document.webkitFullscreenElement || 
                            document.mozFullScreenElement || 
                            document.msFullscreenElement;
        
        if (!isFullscreen) {
          // Normal mode - hide overlay immediately when mouse leaves
          screenshotOverlay.style.opacity = '0';
          screenshotOverlay.style.pointerEvents = 'none';
        } else {
          // Fullscreen mode - start timer
          resetOverlayTimer();
        }
      }
    });
    
    // Handle mouse enter on container
    screenshotContainer.addEventListener('mouseenter', () => {
      isMouseOverContainer = true;
      const isFullscreen = document.fullscreenElement || 
                          document.webkitFullscreenElement || 
                          document.mozFullScreenElement || 
                          document.msFullscreenElement;
      
      if (isFullscreen) {
        // Fullscreen mode - show overlay and start timer
        screenshotOverlay.style.opacity = '1';
        screenshotOverlay.style.pointerEvents = 'auto';
        resetOverlayTimer();
      } else {
        // Normal mode - show overlay immediately
        screenshotOverlay.style.opacity = '1';
        screenshotOverlay.style.pointerEvents = 'auto';
      }
    });
    
    // Handle mouse leave from container
    screenshotContainer.addEventListener('mouseleave', () => {
      isMouseOverContainer = false;
      // Only hide if mouse is not over overlay either
      if (!isMouseOverOverlay) {
        const isFullscreen = document.fullscreenElement || 
                            document.webkitFullscreenElement || 
                            document.mozFullScreenElement || 
                            document.msFullscreenElement;
        
        if (!isFullscreen) {
          // Normal mode - hide overlay immediately when mouse leaves container
          screenshotOverlay.style.opacity = '0';
          screenshotOverlay.style.pointerEvents = 'none';
        } else {
          // Fullscreen mode - start timer
          resetOverlayTimer();
        }
      }
    });
    
    // Mouse move detection for both container and overlay
    screenshotContainer.addEventListener('mousemove', resetOverlayTimer);
    screenshotOverlay.addEventListener('mousemove', resetOverlayTimer);
    
    // Reset timer on key press
    document.addEventListener('keydown', resetOverlayTimer);
    
    // Reset timer on fullscreen button click
    fullscreenBtn.addEventListener('click', resetOverlayTimer);
    
    fullscreenBtn.addEventListener('click', toggleFullscreen);
    
    function toggleFullscreen() {
      if (!document.fullscreenElement) {
        // Enter fullscreen
        if (screenshotContainer.requestFullscreen) {
          screenshotContainer.requestFullscreen().catch(err => {
            console.error('Error attempting to enable fullscreen:', err);
          });
        } else if (screenshotContainer.webkitRequestFullscreen) { /* Safari */
          screenshotContainer.webkitRequestFullscreen();
        } else if (screenshotContainer.msRequestFullscreen) { /* IE11 */
          screenshotContainer.msRequestFullscreen();
        }
      } else {
        // Exit fullscreen
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.webkitExitFullscreen) { /* Safari */
          document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) { /* IE11 */
          document.msExitFullscreen();
        }
      }
    }
    
    // Listen for fullscreen change events to handle container size properly
    document.addEventListener('fullscreenchange', handleFullscreenChange);
    document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
    document.addEventListener('msfullscreenchange', handleFullscreenChange);
    
    function handleFullscreenChange() {
      const imageSizeContainer = document.getElementById('imageSizeContainer');
      const isFullscreen = document.fullscreenElement || 
                          document.webkitFullscreenElement || 
                          document.mozFullScreenElement || 
                          document.msFullscreenElement;
      
      if (isFullscreen) {
        // Remove inline styles when entering fullscreen to allow CSS to take over
        imageSizeContainer.style.width = '';
        imageSizeContainer.style.height = '';
      } else {
        // Restore inline styles when exiting fullscreen
        if (screenshotImg.width && screenshotImg.height) {
          imageSizeContainer.style.width = screenshotImg.width + 'px';
          imageSizeContainer.style.height = screenshotImg.height + 'px';
        }
      }
    }
    
    // Keyboard shortcut for fullscreen (F key)
    document.addEventListener('keydown', (event) => {
      // Only trigger if F key is pressed and chat input is not focused
      if (event.key === 'f' || event.key === 'F') {
        // Check if chat input is focused
        const isChatInputFocused = document.activeElement === llmChatInput;
        
        if (!isChatInputFocused) {
          event.preventDefault(); // Prevent default browser behavior
          toggleFullscreen();
        }
      }
    });
    
    // Make screenshot container focusable and handle focus for keyboard navigation
    screenshotContainer.setAttribute('tabindex', '0');
    screenshotContainer.addEventListener('focus', () => {
      screenshotContainer.classList.add('focused');
    });
    
    screenshotContainer.addEventListener('blur', () => {
      screenshotContainer.classList.remove('focused');
    });
    
    // Also allow fullscreen when container is focused and Enter key is pressed
    screenshotContainer.addEventListener('keydown', (event) => {
      if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault();
        toggleFullscreen();
      }
    });
    
    // Focus screenshot container when clicked with left mouse button
    screenshotContainer.addEventListener('mousedown', (event) => {
      // Only handle left mouse button clicks (button 0)
      if (event.button === 0) {
        event.preventDefault();
        screenshotContainer.focus();
      }
    });
    
    // Also focus when the image itself is clicked (in case click doesn't bubble properly)
    screenshotImg.addEventListener('mousedown', (event) => {
      if (event.button === 0) {
        event.preventDefault();
        screenshotContainer.focus();
      }
    });
    
    // Test function to verify task creation works
    function testTaskCreation() {
      console.log('Testing task creation...');
      handleTaskCreation('Test task message for demonstration purposes');
    }
    
    // Uncomment the line below to test the task creation functionality
    // testTaskCreation();
  </script>
</body>
</html>
